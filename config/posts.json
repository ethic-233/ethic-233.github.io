{
  "posts": [
    {
      "content": "![](https://ethic-233.github.io/post-images/1666155456401.gif)# Spring注解驱动开发\r\n\r\n## bean的生命周期\r\n\r\nbean的生命周期：bean创建、初始化、销毁的过程\r\n\r\n容器管理bean的生命周期，我们可以自定义初始化和销毁方法，容器在bean进行到当前生命周期的时候来调用我们自定义的初始化和销毁方法\r\n\r\n- 构造（对象创建）：单实例——在容器启动的时候创建对象，多实例——在每次获取的时候创建对象\r\n- `BeanPostProcessor.postProcessBeforeInitialization`\r\n- 初始化：对象创建完成，并赋值好，调用初始化方法\r\n- 销毁：单实例——容器关闭的时候，多实例——容器不会管理这个bean，容器不会调用销毁方法\r\n\r\napplyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);\r\n\r\ninvokeInitMethods(beanName, wrappedBean, mbd);  执行初始化\r\n\r\n遍历得到容器中所有的BeanPostProcessor：挨个执行beforeInititalization，\r\n\r\n一旦返回null，跳出for循环，不会执行后面的BeanPostProcessor，就是PostProcessorsBeforeInititalization\r\n\r\n1. 指定初始化和销毁方法：\r\n\r\n   通过@Bean指定`init-method`和`destroy-method` \r\n\r\n2. 通过让Bean实现`InitializingBean`（定义初始化逻辑），`DisposableBean`（定义销毁逻辑）\r\n\r\n3. 可以使用JSR250，@PostConstruct：在bean创建完成并且属性赋值完成，来执行初始化方法\r\n\r\n   @PreDestroy：在容器销毁bean之前通知我们进行清理工作\r\n\r\n4. `BeanPostProcessor`：bean的后置处理器，在bean初始化前后进行一些处理工作：\r\n\r\n   `postProcessBeforeInitialization`：在初始化之前工作\r\n\r\n   `postProcessAfterInitialization`：在初始化之后工作\r\n\r\nSpring底层对BeanPostProcessor的使用：\r\n\r\nbean赋值，注入其他组件，@Autowired，生命周期注解功能，@Async   xxx\r\n\r\n## 组件添加\r\n\r\n### `@Configuration`\r\n\r\n告诉Spring这是一个配置类\r\n\r\n对应的IOC容器是`AnnotationConfigApplicationContext`\r\n\r\n```java\r\nnew AnnotationConfigApplicationContext(配置类.class);\r\n```\r\n\r\n### `@Bean`\r\n\r\n给容器中注册一个Bean，类型为返回值的类型，id是默认用方法名做id\r\n\r\n```java\r\n@Bean(\"person\")\r\npublic Person person01(){\r\n    return new Person(\"ethic\",20);\r\n}\r\n```\r\n\r\n注册了一个名为person的组件\r\n\r\n### `@ComponentScan`\r\n\r\n包扫描，只要标注了`@Controller`，`@Service`，`@Repository`，`@Component`\r\n\r\n```xml\r\n<context:component-scan base-package=\"包名\"></context:component-scan>\r\n```\r\n\r\n在配置类里类名上面\r\n\r\n```java\r\n@ComponentScan(value=\"包名\", excludeFilters = {\r\n\t@Filter(type=FilterType.ANNOTATION, classes={Controller.class}),\r\n    @Filter(type=FilterType.ASSIGNABLE_TYPE, classes={BookService.class}),\r\n    @Filter(type=FilterType.CUSTOM, classes={MyTypeFilter.class})\r\n}, useDefaultFilters = false)\r\n```\r\n\r\n`value`：指定要扫描的包\r\n\r\n`excludeFilters = Filter[]`：指定扫描的时候按照什么规则排除那些组件\r\n\r\n`includeFilters = Filter[]`：指定扫描的时候只需要包含那些组件\r\n\r\n`FilterType.ANNOTATION`：按照注解\r\n\r\n`FilterType.ASSIGNABLE_TYPE`：按照给定的类型\r\n\r\n`FilterType.ASPECTJ`：使用ASPECTJ表达式\r\n\r\n`FilterType.REGEX`：使用正则指定\r\n\r\n`FilterType.CUSTOM`：使用自定义规则\r\n\r\n读取到的当前正在扫描的类的信息：`metadataReader`\r\n\r\n```java\r\n// 获取当前类注解的信息\r\nAnnotationMetadata anno = metadataReader.getAnnotationMetadata();\r\n// 获取当前正在扫描的类信息\r\nClassMetadata classMetadata = metadataReader.getClassMetadata();\r\n// 获取当前类资源(类的路径)\r\nResource resource = metadataReader.getResource();\r\nString className = classMetadata.getClassName();\r\n```\r\n\r\n可以获取到其他任何类信息的：`metadataReaderFactory`\r\n\r\n### `@Controller`\r\n\r\n### `@Service`\r\n\r\n### `@Repository`\r\n\r\nDao层的东西\r\n\r\n### `@Scope`\r\n\r\n```java\r\n@Scope(\"prototype\")\r\n```\r\n\r\n`prototype`：多实例的，ioc容器启动并不会去调用方法创建对象放在容器中，每次获取的时候才会调用方法创建对象\r\n\r\n`singleton`：单实例的（默认值），ioc容器启动会调用方法创建对象放到ioc容器中，以后每次获取就是直接从容器中（`map.get()`）拿\r\n\r\n`request`：同一次请求创建一个实例\r\n\r\n`session`：同一个session创建一个实例\r\n\r\n### `@Lazy`\r\n\r\n懒加载：单实例bean，默认在容器启动的时候创建对象。但懒加载是容器启动的时候不创建对象，第一次使用（获取）Bean创建对象，并初始化\r\n\r\n### `@Component`\r\n\r\n### `@Conditional`\r\n\r\n按照一定的条件进行判断，满足条件给容器中注册bean\r\n\r\n`ConditionContext`：判断条件能使用的上下文（环境）\r\n\r\n`AnnotatedTypeMetadata`：注释信息\r\n\r\n```java\r\npublic boolean matches(ConditionContext context, AnnotatedType anno){\r\n    // 能获取到ioc使用的beanfactory\r\n    ConfigurableListableBeanFactory beanFactory = context.getBeanFactory();\r\n\t// 获取类加载器\r\n    ClassLoader classLoader = context.getClassLoader();\r\n    // 获取当前环境信息\r\n    Environment environment = context.getEnvironment();\r\n    // 获取到bean定义的注册类\r\n    BeanDefinitionRegistry registry = context.getRegistry();\r\n    \r\n    String property = environment.getProperty(\"os.name\");\r\n    if(property.contains(\"linux\")){\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n```\r\n\r\n### `@Primary`\r\n\r\n### `@Import`\r\n\r\n### ImportSelector\r\n\r\n### 工厂模式\r\n\r\n## 组件赋值\r\n\r\n### 自动装配\r\n\r\nSpring利用依赖注入（DI），完成对IOC容器中各个组件的依赖关系赋值\r\n\r\n- @Autowired  自动注入：\r\n\r\n  - 默认优先按类型去容器中找对应的组件：applicationContext.getBean(BookDao.class);  找到就赋值\r\n\r\n    ```java\r\n    BookService{\r\n        @Autowired\r\n        BookDao bookDao;\r\n    }\r\n    ```\r\n\r\n  - 如果找到多个相同类型的组件，再将属性的名称作为组件的id去容器中查找：applicationContext.getBean(\"bookDao\");\r\n\r\n  - @Qualifier(\"bookDao\")：使用@Qualifier指定需要装配的组件的id，而不是使用属性名\r\n\r\n  - 自动装配默认一定要将属性赋值好，没有就会报错\r\n\r\n    可以使用`@Autowired(required=false)`\r\n\r\n  - @Primary：让Spring进行自动装配的时候，默认使用首选的bean\r\n\r\n    也可以继续使用@Qualifier指定需要装配的bean的名字\r\n\r\n- Spring还支持使用@Resource(JSR250)和@Inject(JSR330)[java规范的注解]\r\n\r\n  - `@Resource`：可以和@Autowired一样实现自动装配功能，默认是按照组件名称进行装配的；没有能支持@Primary功能没有支持@Autowired(required=false)\r\n  - `@Inject`：需要导入javax.inject的包，和Autowired的功能一样，没有required=false的功能\r\n  - `@Autowired`：Spring定义的，@Resource，@Inject都是java规范\r\n\r\n  AutowiredAnnotationBeanPostProcessor：解析完成自动装配功能\r\n\r\n- @Autowired：构造器，参数，方法，属性\r\n\r\n  都是从容器中获取参数组件的值\r\n\r\n  - 标注在方法位置：@Bean+方法参数；参数从容器中获取\r\n\r\n    默认不写@Autowired效果是一样的；都能自动装配\r\n\r\n  - 标在构造器上：如果组件只有一个有参构造器，这个有参构造器的@Autowired可以省略，参数位置的组件还是可以自动从容器中获取\r\n\r\n  - 放在参数位置\r\n\r\n- 自定义组件想要使用Spring容器底层的一些组件（ApplicationContext，BeanFactory，xxx），自定义组件实现xxxAware；在创建对象的时候，会调用接口规定的方法注入相关组件；把Spring底层一些组件注入到自定义的Bean中\r\n\r\n  - xxxAware：功能是使用xxxProcessor\r\n\r\n    ApplicationContextAware → ApplicationContextAwareProcessor\r\n\r\n### `@Value`\r\n\r\n使用@Value赋值：\r\n\r\n1. 基本数值\r\n2. 可以写SpEl：#{}\r\n3. 可以写${}：取出配置文件中的值（在运行环境变量里面的值）\r\n\r\n```java\r\n@Value(\"张三\")\r\nprivate String name;\r\n@Value(\"#{20-2}\")\r\nprivate Integer age;\r\n\r\n```\r\n\r\n### `@PropertySource`\r\n\r\n读取外部配置文件中的k/v保存到运行的环境变量中\r\n\r\n加载完外部的配置文件后使用${}取出配置文件的值\r\n\r\n`@PropertySource(value={\"classpath:/person.properties\"})`\r\n\r\n### `@PropertySources`\r\n\r\n### `@Profile`\r\n\r\nSpring为我们提供的可以根据当前环境，动态的激活和切换一系列组件的功能\r\n\r\n开发环境、测试环境、生产环境\r\n\r\n`@Profile`：指定组件在哪个环境的情况下才能被注册到容器中，不指定，任何环境下都能注册这个组件\r\n\r\n- 使用命令行动态参数：在虚拟机参数位置加载`-Dspring.profiles.active=test`\r\n\r\n  加了环境标识的bean，只有这个环境被激活的时候才能注册到容器中，默认是default环境\r\n\r\n  - 创建一个applicationContext\r\n\r\n    ```java\r\n    AnnotationConfigApplicationContext applicationContext = new AnnocationConfigApplicationContext();\r\n    \r\n    ```\r\n\r\n  - 设置需要激活的环境\r\n\r\n    ```java\r\n    applicationContext.getEnvironment().setActiveProfiles(\"test\",\"dev\");\r\n    \r\n    ```\r\n\r\n  - 配置主配置类\r\n\r\n    ```java\r\n    applicationContext.register(MainConfigOfProfile.class);\r\n    \r\n    ```\r\n\r\n  - 启动刷新容器\r\n\r\n    ```java\r\n    applicationContext.refresh();\r\n    \r\n    ```\r\n\r\n- 代码的方式激活某种环境\r\n\r\n  写在配置类上，只有是指定的环境的时候，整个配置类里面的所有配置才能开始生效\r\n\r\n  没有标注环境标识的bean在，任何环境下都是加载的\r\n\r\n## 组件注入\r\n\r\n### 给容器中注册组件\r\n\r\n- 包扫描+组件标注注解（@Controller/@Service/@Repository/@Component）[自己写的类]\r\n\r\n- @Bean[导入的第三方包里的组件]\r\n\r\n- @Import[快速给容器中导入一个组件]\r\n\r\n  - @Import（要导入到容器中的组件），容器中就会自动注册这个组件，id默认是全类名\t\r\n  - `ImportSelector`：返回需要导入的组件的全类名数组\r\n  - `ImportBeanDefinitionRegister`：手动注册bean到容器中\r\n\r\n- 使用Spring提供的`FactoryBean`（工厂bean） \r\n\r\n  - 默认获取到的是工厂bean调用getObject创建的对象\r\n\r\n  - 要获取工厂bean本身，我们需要给id前面加一个&\r\n\r\n    &colorFactoryBean\r\n\r\n```java\r\n/*\r\n自定义逻辑返回需要导入的组件，返回值，就是导入到容器中的组件全类名\r\nAnnotationMetadata：当前标注@Import注解的类的所有注解信息\r\n*/\r\npublic class MyImportSelector implements ImportSelector {\r\n    @Override\r\n    public String[] selectImport(AnnotationMetadata importingClassMetadata){\r\n        importingClassMetadata.\r\n        // 方法不要返回null值\r\n        return new String[]{\"全类名1\",\"全类名2\"};\r\n    }\r\n}\r\n\r\n```\r\n\r\n```java\r\n/* \r\nAnnotationMetadata：当前类的注解信息\r\nBeanDefinitionRegistry：BeanDefinition注册类\r\n\t把所有需要添加到容器中的bean：用BeanDefinitionRegistry.registerBeanDefinition手工注册进来\r\n*/\r\npublic class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegister {\r\n    @Override\r\n    public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata){\r\n \t\tboolean definition1 = register.containsBeanDefinition(\"全类名1\");       \r\n    \tboolean definition2 = register.containsBeanDefinition(\"全类名2\");\r\n    \tif(definition1 && definition2){\r\n            // bean的定义信息, bean的类型、作用域...\r\n            RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class);\r\n            // 注册一个bean, 指定bean名\r\n            registry.registerBeanDefinition(\"rainBow\",beanDefinition);\r\n        }\r\n    }\r\n}\r\n\r\n```\r\n\r\n`MainConfig`里面\r\n\r\n```java\r\n@Import({类名.class, MyImportSelector.class})\r\n\r\n```\r\n\r\n## AnnotationConfigApplicationContext\r\n\r\n## 声明式事务\r\n\r\n环境搭建\r\n\r\n1. 导入相关依赖\r\n\r\n   数据源、数据库驱动、Spring-jdbc模块\r\n\r\n2. 配置数据源，JdbcTemplate（Spring提供的简化数据库操作的工具）操作数据\r\n\r\n3. 给方法上标注@Transactional表示当前方法是一个事务方法\r\n\r\n4. @EnableTransactionManagement开启基于注解的事务管理功能\r\n\r\n5. 配置事务管理器来控制事务\r\n\r\n   @Bean\r\n\r\n   public PlatformTransactionManager transactionManager()\r\n\r\n## AOP\r\n\r\nAOP：动态代理，指在程序运行期间动态的将某段代码切入到指定方法指定位置进行运行的编程方式\r\n\r\n1. 导入AOP模块：Spring AOP：（spring-aspects）\r\n\r\n2. 定义一个业务逻辑类（spring-aspects）：在业务逻辑运行的时候将日志进行打印（方法之前，方法运行结束，方法出现异常）\r\n\r\n3. 定义一个日志切面类（LogAspects）：切面类里面的方法需要动态感知MathCalculator.div运行到哪里然后执行\r\n\r\n   通知方法\r\n\r\n   - 前置通知（@Before）：logStart，在目标方法（div）运行之前运行\r\n\r\n     @Before在目标方法之前切入：切入点表达式（指定在哪个方法切入）\r\n\r\n     ```java\r\n     @Before(\"public int com.aop.MathCalculator.div.*(int, int)\")\r\n     \r\n     ```\r\n\r\n   - 后置通知（@After）：logEnd，在目标方法（div）运行结束之后运行（无论方法正常结束还是异常结束）\r\n\r\n   - 返回通知（@AfterReturning）：logReturn，在目标方法（div）正常返回之后运行\r\n\r\n   - 异常通知（@AfterThrowing）：logException，在目标方法（div）出现异常以后运行\r\n\r\n   - 环绕通知（@Around）：动态代理，手动推进目标方法运行（joinPoint.procced()）\r\n\r\n   抽取公共的切入点表达式\r\n\r\n   - 本类引用\r\n   - 其他的切面引用\r\n\r\n4. 给切面类的目标方法标注何时何地运行（通知注解）\r\n\r\n5. 将切面类和业务逻辑类（目标所在方法类）都加入到容器中\r\n\r\n6. 必须告诉Spring哪个类是切面类（给切面类加上一个注解：@Aspect）\r\n\r\n7. 给配置类中加@EnableAspectJAutoProxy（开启基于AspectJ的自动代理，基于注解的AOP模式）\r\n\r\n   JoinPoint一定要出现在参数表的第一位\r\n\r\n三步：\r\n\r\n- 将业务逻辑组件和切面类都加入到容器中，告诉Spring哪个是切面类（@Aspect）\r\n- 在切面类上的每一个通知方法上标注通知注解，告诉Spring何时何地运行（切入点表达式）\r\n- 开启基于注解的AOP模式：@EnableAspectJAutoProxy\r\n\r\nAOP原理（看给容器中注册了什么组件，这个组件什么时候工作，这个组件的功能是什么）：\r\n\r\n@EnableAspectJAutoProxy\r\n\r\n- 是什么？\r\n\r\n  @Import(AspectJAutoProxyRegistrar.class)：给容器中导入AspectJAutoProxyRegistrar\r\n\r\n  利用AspectJAutoProxyRegistrar自定义给容器中注册bean：\r\n\r\n  internalAutoProxyCreator=AnnotationAwareAspectJAutoProxyCreator\r\n\r\n  给容器注册一个AnnotationAwareAspectJAutoProxyCreator，（注解装配的切面自动代理创建器\r\n\r\n- AnnotationAwareAspectJAutoProxyCreator\r\n\r\n## 扩展原理\r\n\r\n### BeanFactoryPostProcessor\r\n\r\nBeanPostProcessor：bean后置处理器，bean创建对象初始化前后进行拦截工作的\r\n\r\nBeanFactoryPostProcessor：beanFactory的后置处理器，在BeanFactory标准初始化之后调用，所有的bean定义已经保存加载到beanFactory，但是bean的实例还未创建\r\n\r\n1. IOC容器创建对象\r\n\r\n2. invokeBeanFactoryPostProcessors(beanFactory);  执行BeanFactoryPostProcessor\r\n\r\n   如何找到所有的BeanFactoryPostProcessor并执行他们的方法\r\n\r\n   - 直接在BeanFactory中找到所有类型是BeanFactoryPostProcessor的组件，并执行他们的方法\r\n   - 在初始化创建其他组件前面执行\r\n\r\n### BeanDefinitionRegistryPostProcessor\r\n\r\npostProcessBeanDefinitionRegistry();\r\n\r\n在所有bean定义信息将要被加载，bean实例还未创建的\r\n\r\n优先于BeanFactoryPostProcessor执行，利用BeanDefinitionRegistryPostProcessor给容器中再额外添加一些组件\r\n\r\n原理：\r\n\r\n1. IOC创建对象\r\n2. refresh() → invokeBeanFactoryPostProcessors(beanFactory);\r\n3. 从容器中获取到所有的BeanDefinitionRegistryPostProcessor组件\r\n   - 依次触发所有的postProcessBeanDefinitionRegistry()方法\r\n   - 再来触发postProcessBeanFactory()方法BeanFactoryPostProcessor里的\r\n4. 再来从容器中找到BeanFactoryPostProcessor组件，然后依次触发postProcessBeanFactory()方法\r\n\r\n### ApplicationListener\r\n\r\n监听容器中发布的事件，事件驱动模型开发\r\n\r\n监听ApplicationEvent及其下面的子事件\r\n\r\n步骤：\r\n\r\n1. 写一个监听器（ApplicationListener实现类）来监听某个事件（ApplicationEvent及其子类）\r\n\r\n   @EventListener\r\n\r\n   原理：使用EventListenerMethodProcessor处理器来解析方法上的@EventListener\r\n\r\n2. 把监听器加入到容器\r\n\r\n3. 只要容器中有相关事件发布，我们就能监听到这个事件\r\n\r\n   ContextRefreshedEvent：容器刷新完成（所有bean都完全创建）会发布这个事件\r\n\r\n   ContextClosedEvent：关闭容器会发布这个事件\r\n\r\n4. 发布一个事件：applicationContext.publishEvent();\r\n\r\n原理：\r\n\r\nContextRefreshedEvent事件\r\n\r\n1. 容器创建对象：refresh()\r\n2. finishRefresh();  容器刷新完成会发布ContextRefreshedEvent事件\r\n3. 自己发布事件\r\n4. 容器关闭会发布ContextClosedEvent\r\n\r\npublishEvent(new ContextRefreshedEvent(this));\r\n\r\n事件发布流程：\r\n\r\n- 获取事件的多播器：getApplicationEventMuticaster()\r\n\r\n- muticastEvent 派发事件\r\n\r\n- 获取到所有的ApplicationListener\r\n\r\n  ```java\r\n  for(final ApplicationListener<?> listener:getApplicationListeners(event,type))\r\n  \r\n  ```\r\n\r\n  - 如果有Executor，可以支持使用Executor进行异步派发\r\n\r\n    ```java\r\n    Executor executor = getTaskExecutor();\r\n    \r\n    ```\r\n\r\n  - 否则，同步的方式直接执行listener方法：invokeListener(listener, event);\r\n\r\n    拿到listener回调onApplicationEvent方法\r\n\r\n容器中有哪些监听器：\r\n\r\n1. 容器创建对象：refresh()\r\n\r\n2. initApplicationEventMulticaster(); 初始化ApplicationEventMulticaster\r\n\r\n   - 先去容器中找有没有id=\"applicationEventMulticaster\"的组件\r\n\r\n   - 如果没有this.applicationEventMulticaster = new SimpleApplicationEventMulticaster(beanFactory)\r\n\r\n     并且加入到容器中，我们就可以在其他组件要派发事件，自动注入这个applicationEventMulticaster\r\n\r\nSmartInitializingSingleton原理：\r\n\r\n1. IOC容器创建对象并refresh()\r\n\r\n2. finishBeanFactoryInitialization(beanFactory);  初始化剩下的单实例bean\r\n\r\n   - 先创建所有单实例bean，getBean()\r\n\r\n   - 获取所有创建好的单实例bean，判断是否是SmartInitializingSingleton类型的\r\n\r\n     如果是，就调用afterSingletonsInstantiated();\r\n\r\nBeanFactory的创建和预准备工作：\r\n\r\n1. prepareRefresh()  刷新前的预处理\r\n\r\n   - initPropertySource()  初始化一些属性设置，子类自定义个性化的属性设置方法\r\n   - getEnvironment().validateRequiredProperties();  检验属性的合法等\r\n   - `earlyApplicationEvents = new LinkedHashSet<ApplicationEvent>();`保存容器中的一些早期事件\r\n\r\n2. obtainFreshBeanFactory();  获取BeanFactory\r\n\r\n   - refreshBeanFactory();  刷新BeanFactory\r\n\r\n     创建了一个`this.beanFactory = new DefaultListableBeanFactory();`\r\n\r\n     设置id\r\n\r\n   - getBeanFactory(); 返回刚才GenericApplicationContext创建的BeanFactory对象\r\n\r\n   - 将创建的BeanFactory（DefaultListableBeanFactory）返回\r\n\r\n3. prepareBeanFactory(beanFactory);  BeanFactory的预准备工作（BeanFactory进行一些设置）\r\n\r\n   - 设置BeanFactory的类加载器，支持表达式解析器\r\n   - 添加部分BeanPostProcessor（ApplicationContextAwareProcessor）\r\n   - 设置忽略的自动装配的接口EnvironmentAware，EmbeddedValueResolverAware\r\n   - 注册可以解析的自动装配：我们能直接在任何组件中自动注入：BeanFactory，ResourceLoader，ApplicationEventPublisher，ApplicationContext\r\n   - 添加BeanPostProcessor（ApplicationListenerDetector）\r\n   - 添加编译时的AspectJ\r\n   - 给BeanFactory中注册一些能用的组件：environment（ConfigurableEnvironment），systemProperties（Map<String, Object>），systemEnvironment（Map<String, Object>）\r\n\r\n4. postProcessBeanFactory(beanFactory);  BeanFactory准备工作完成后进行的后置处理工作\r\n\r\n   - 子类通过重写这个方法来在BeanFactory创建并预准备完成以后做进一步的设置\r\n\r\n### SmartInitializingSingleton\r\n\r\n### Spring容器创建过程\r\n\r\n## 运行时插件\r\n\r\nShared libraries （共享库）/ runtimes pluggability（运行时插件能力）\r\n\r\n1. Servlet容器启动会扫描，当前应用里面每一个jar包\r\n\r\n   ServletContainerInitializer的实现\r\n\r\n2. 提供ServletContainerInitializer的实现类\r\n\r\n   必须绑定在，META-INF/services/javax.servlet.ServletContainerInitializer\r\n\r\n   文件的内容就是ServletContainerInitializer实现类的全类名\r\n\r\n总结：容器在启动应用的时候，会运行onStartup方法，会扫描当前应用每一个jar包里面\r\n\r\nMETA-INF/services/javax.servlet.ServletContainerInitializer\r\n\r\n指定的实现类，启动并运行这个实现类的方法：传入感兴趣的类型\r\n\r\n加载这个文件指定的类SpringServletContainerInitializer\r\n\r\n1. 使用ServletContext注册Web组件（Servlet，Filter，Listener）\r\n\r\n2. 使用编码的方式，在项目启动时给ServletContext里面添加组件\r\n\r\n   必须在项目启动的时候来添加\r\n\r\n   - ServletContainerInitializer得到的ServletContext对象\r\n   - ServletContextListener得到的ServletContext\r\n\r\n3. Spring的应用一启动会加载感兴趣的WebApplicationInitializer接口下的所有组件\r\n\r\n4. 并且为WebApplicationInitializer组件创建对象（组件不是接口，不是抽象类）\r\n\r\n   - AbstractContextLoaderInitializer：创建根容器，createRootApplicationContext()\r\n\r\n   - AbstractDispatcherServletInitializer\r\n\r\n     创建一个web的IOC容器：createServletApplicationContext();\r\n\r\n     创建了DispatcherServlet：createDispatcherServlet();\r\n\r\n     将创建的DispatcherServlet添加到ServletContext中\r\n\r\n     getServletMappings();\r\n\r\n   - AbstractAnnotationConfigDispatcherServletInitializer：注解方式配置的DispatcherServlet初始化器\r\n\r\n     创建根容器：createRootApplicationContext()\r\n\r\n     ​\t\tgetRootConfigClasses();  传入一个配置类\r\n\r\n     创建web的IOC容器：createServletApplicationContext();\r\n\r\n     ​\t\t获取配置类：getServletConfigClasses();\r\n\r\n总结：以注解方式来启动SpringMVC：继承AbstractAnnotationConfigDispatcherServletInitializer\r\n\r\n实现抽象方法指定DispatcherServlet的配置信息\r\n\r\n定制SpringMVC：\r\n\r\n1. @EnableWebMvc：开启SpringMVC定制配置功能\r\n\r\n   `<mvc:annotation-driven/>`\r\n\r\n2. 配置组件（视图解析器，视图映射，静态资源映射，拦截器）\r\n\r\n   extends WebMvcConfigurerAdapter\r\n\r\n## SpringMVC的异步操作\r\n\r\n1. 控制器返回Callable\r\n2. Spring异步处理，将Callable提交到TaskExecutor使用一个隔离的线程进行执行\r\n3. DispatcherServlet和所有的Filter退出web容器的线程，但是response保持打开状态\r\n4. Callable返回结果，SpringMVC将请求重新派发给容器，恢复之前的处理\r\n5. 根据Callable返回的结果，SpringMVC继续进行视图渲染流程等（从收请求-视图渲染）",
      "data": {
        "title": "Spring注解驱动开发",
        "date": "2022-10-19 12:34:57",
        "tags": [
          "Spring"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "spring"
    },
    {
      "content": "![](https://ethic-233.github.io/post-images/1666155479780.jpg)final\r\n\r\nfinal是一个修饰符\r\n\r\n    被final修饰的量的值不可变\r\n\r\n    被final修饰的方法不可被重写\r\n\r\n    被final修饰的类不可被继承\r\n\r\n    final不能修饰抽象类和接口(抽象类和接口必须要被实体类继承才能创建对象) ,也不能修饰抽象方法(抽象方法必须被重写)\r\n\r\n    在 final 定义的方法里，不是必须要用 final 定义变量\r\n\r\n    final 定义的变量，可以在不是必须要在定义的同时完成初始化，也可以在构造方法中完成初始化\r\n\r\n    final修饰方法，不能被子类重写，但是可以被重载\r\n\r\n    final 定义变量，可以用 static 也可以不用\r\n\r\n    final定义的成员变量可以在代码块(类变量则静态代码块，实例变量普通代码块)里初始化，也可以在构造器中初始化，也可以在声明变量时初始化。final的局部变量声明时不必马上初始化，但使用时必须初始化，而且只能一次赋值 \r\n\r\nint\r\n\r\nint是基本类型，直接存数值，Integer是对象，用一个引用指向这个对象\r\n集合框架\r\n\r\nLinkedList 和 ArrayList 都是不同步的，线程不安全； Vector 和 Stack 都是同步的，线程安全； Set是线程不安全的；\r\n\r\nHashSet，是线程安全的，不允许存储相同的对象；\r\n\r\nHashtable的方法是同步的，线程安全； HashMap的方法不是同步的，线程不安全；\r\n\r\nConcurrentHashMap，是线程安全的，其中存储的键对象可以重复，值对象不能重复；\r\n访问修饰符\r\n\r\n\tpublic \tprotected \tdefault \tprivate\r\n同包同类 \t√ \t√ \t√ \t√\r\n同包不同类 \t√ \t√ \t√ \t\r\n同包不同类继承 \t√ \t√ \t√ \t\r\n不同包继承 \t√ \t√ \t\r\n\t\r\n不同包无任何关系的类 \t√ \t\r\n\t\r\n\t\r\n\r\n实际开发的时候禁止使用default\r\n\r\n接口方法的修饰符可以是：public，abstract，default，static（后两者需要有{}）\r\n\r\n构造方法可以用private，protected，default，private\r\n\r\n类、方法、成员变量和局部变量的可用修饰符：\r\n修饰符 \t类 \t成员访问 \t构造方法 \t成员变量 \t局部变量\r\nabstract（抽象的） \t√ \t√ \t\r\n\t\r\n\t\r\nstatic（静态的） \t\r\n\t√ \t\r\n\t√ \t\r\npublic（公共的） \t√ \t√ \t√ \t√ \t\r\nprotected（受保护的） \t\r\n\t√ \t√ \t√ \t\r\nprivate（私有的） \t\r\n\t√ \t√ \t√ \t\r\nsynchronized（同步的） \t\r\n\t√ \t\r\n\t\r\n\t\r\nnative（本地的） \t\r\n\t√ \t\r\n\t\r\n\t\r\ntransient（暂时的） \t\r\n\t\r\n\t\r\n\t√ \t\r\nvolatile（易失的） \t\r\n\t\r\n\t\r\n\t√ \t\r\nfinal（不要改变的） \t√ \t√ \t\r\n\t√ \t√\r\n垃圾回收\r\n\r\n一旦一个对象成为垃圾，就立刻被收集掉。\r\n\r\n答: 这个是jvm的东西，暂时不做要求\r\n\r\n垃圾什么时候收集看回收算法，但肯定不是立刻收集\r\n抽象类和接口\r\n\r\nabstract class和interface所反映出的设计理念不同。其实abstract class表示的是\"is-a\"关系，interface表示的是\"has-a\"关系。\r\n\r\n    接口里不允许有普通属性，只能有抽象方法(java8之前),因此接口仅仅表示这个东西有这些操作，所以是has-a\r\n\r\n    抽象类作为一个类本身就表示这个东西是什么(可以具体的给出属性和方法)，所以是is-a \r\n\r\n接口是公开的，里面不能有私有的方法或变量，是用于让别人使用的，而抽象类是可以有私有方法或私有变量的。\r\n\r\nabstract class 在 Java 语言中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface，实现多重继承。接口还有标识（里面没有任何方法，如Remote接口）和数据共享（里面的变量全是常量）的作用。\r\n\r\n在abstract class 中可以有自己的数据成员，也可以有非abstarct的成员方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是 static final的，不过在 interface中一般不定义数据成员），所有的成员方法默认都是 public abstract 类型的。\r\n\r\njava中接口只能使用public修饰，接口内方法默认为public abstract\r\n\r\n当一个实体类继承一个抽象类，必须实现抽象类中的抽象方法\r\n\r\njava 接口中可以定义成员变量，且必须是 static final的\r\n\r\n抽象类可以实现接口，抽象类实现接口其所具有的意义：\r\n\r\n    一般而言，多使用普通类来实现接口，但是普通类实现接口的话就必须实现接口的所有方法，这样容易造成代码冗余。\r\n\r\n    而如果使用抽象类来实现接口，然后再用普通类继承抽象类的话，其仍然可以实现接口中但抽象类中并未实现的方法。以此可以只实现必要的方法，即抽象类中可以不定义对于子类而言必要的方法，而最终交由子类自己来实现。\r\n\r\n    从2中可知，抽象类实现接口时，不必实现接口中的所有方法，未实现的方法可以交由子类来实现。 \r\n\r\n接口中的变量默认是public static final 的，方法默认是public abstract 的\r\n\r\nJDK8中，接口中的方法可以被default和static修饰，但被修饰的方法必须有方法体\r\n默认访问权限\r\n\r\n关于抽象类\r\n\r\nJDK 1.8以前，抽象类的方法默认访问权限为protected\r\n\r\nJDK 1.8时，抽象类的方法默认访问权限变为default\r\n\r\n关于接口\r\n\r\nJDK 1.8以前，接口中的方法必须是public的\r\n\r\nJDK 1.8时，接口中的方法可以是public的，也可以是default的\r\n\r\nJDK 1.9时，接口中的方法可以是private的\r\n异常和错误\r\n\r\n异常（Exception），错误（Error）\r\n\r\n所有的Java异常和错误的基类都是java.lang.Exception, 包括java.lang.RuntimeException\r\n\r\n答: 错误，基类是Throwable\r\n\r\n正确描述: java里所有异常的基类是Exception,所有运行时异常的基类是RuntimeException,所有错误的基类是Error,所有异常和错误的基类是Throwable\r\n\r\n补充: 通过try … catch … finally语句，finally中的语句部分无论发生什么异常都会得到执行\r\n依赖注入\r\n\r\n依赖注入能够独立开发各组件，然后根据组件间关系进行组装\r\n\r\n依赖注入提供使用接口编程\r\n\r\n依赖注入指对象在使用时动态注入\r\n\r\n依赖注入的动机就是减少组件之间的耦合度，使开发更为简洁\r\n类的加载顺序\r\n\r\npublic class Test {   public static Test t1 = new Test(); //静态变量     {   System.out.println(\"blockA\"); //构造块   }     static   {   System.out.println(\"blockB\"); //静态块   }     public static void main(String[] args)   {   Test t2 = new Test();   } }\r\n\r\n静态域：用staitc声明，jvm加载类时执行，仅执行一次 构造代码块：类中直接用{}定义，每一次创建对象时执行。\r\n\r\n执行顺序优先级：静态域，main()，构造代码块，构造方法。\r\n\r\n    静态域 ：首先执行，第一个静态域是一个静态变量 public static Test t1 = new Test(); 创建了Test 对象，会执行构造块代码，所以输出blockA。然后执行第二个静态域（即静态代码块）输出blockB\r\n\r\n    main()：Test t2 = new Test()执行，创建Test类对象，只会执行构造代码块（创建对象时执行），输出blockA\r\n\r\n    构造代码块只会在创建对象时执行，没创建任何对象了，所以没输出\r\n\r\n    构造函数：使用默认构造函数，没任何输出 \r\n\r\n类的加载顺序：\r\n\r\n    父类静态对象和静态代码块\r\n\r\n    子类静态对象和静态代码块\r\n\r\n    父类非静态对象和非静态代码块\r\n\r\n    父类构造函数\r\n\r\n    子类非静态对象和非静态代码块\r\n\r\n    子类构造函数 \r\n\r\n其中：类中静态块按照声明执行顺序执行，并且1和2不需要调用new类实例的时候就执行了（意思是类加载到方法区的时候执行的）\r\n代码块\r\n\r\n普通块：方法体内部由大括号括起，执行顺序为按照正常的执行顺序（先出现，先执行）执行\r\n\r\n构造块：类的内部由大括号括起，每次构造对象时都会被调用，且优先于构造函数执行\r\n\r\n静态块：在类的内部使用，形式为static{}，静态块一般用于初始化类，为类的属性初始化，每个静态代码块只会执行一次，执行顺序遵循先定义先执行原则\r\nCountDownLatch与CyclicBarrier\r\n\r\nCountDownLatch 是等待一组线程执行完，才执行后面的代码。此时这组线程已经执行完 CyclicBarrier 是等待一组线程至某个状态后再同时全部继续执行线程。此时这组线程还未执行完\r\nvolatile与synchronized\r\n\r\nvolatile本质是在告诉jvm当前变量在寄存器中的值是不确定的,需要从主存中读取,synchronized则是锁定当前变量,只有当前线程可以访问该变量,其他线程被阻塞住\r\n\r\nvolatile仅能使用在变量级别,synchronized则可以使用在变量,方法\r\n\r\nvolatile仅能实现变量的修改可见性,但不具备原子特性,而synchronized则可以保证变量的修改可见性和原子性\r\n\r\nvolatile不会造成线程的阻塞,而synchronized可能会造成线程的阻塞\r\n\r\nvolatile标记的变量不会被编译器优化,而synchronized标记的变量可以被编译器优化\r\n\r\n可见性： 可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。\r\n\r\n可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。 在 Java 中 volatile、synchronized 和 final 实现可见性。\r\n\r\n原子性： 原子是世界上的最小单位，具有不可分割性。比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以他不是一个原子操作。非原子操作都会存在线程安全问题，需要我们使用同步技术（sychronized）来让它变成一个原子操作。一个操作是原子操作，那么我们称它具有原子性。java的concurrent包下提供了一些原子类，我们可以通过阅读API来了解这些原子类的用法。比如：AtomicInteger、AtomicLong、AtomicReference等。 在 Java 中 synchronized 和在 lock、unlock 中操作保证原子性。\r\n\r\n有序性： Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 是由“一个变量在同一个时刻只允许一条线程对其进行 lock 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。\r\nHashMap和Hashtable\r\n\r\nHashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式 区别1： HashMap可以存放 null Hashtable不能存放null 区别2： HashMap不是线程安全的类 Hashtable是线程安全的类\r\nStringBuffer和StringBuilder\r\n\r\nStringBuffer 是线程安全的 StringBuilder 是非线程安全的\r\n\r\n所以当进行大量字符串拼接操作的时候，如果是单线程就用StringBuilder会更快些，如果是多线程，就需要用StringBuffer 保证数据的安全性\r\n\r\n非线程安全的为什么会比线程安全的快？\r\n\r\n因为不需要同步，省略了些时间\r\nArrayList和Vector\r\n\r\nVector是线程安全的类，ArrayList是非线程安全的\r\n线程安全\r\n\r\n如果一个类，其方法都是有synchronized修饰的，那么该类就叫做线程安全的类\r\n\r\n同一时间，只有一个线程能够进入 这种类的一个实例 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)\r\n\r\n比如StringBuffer和StringBuilder的区别 StringBuffer的方法都是有synchronized修饰的，StringBuffer就叫做线程安全的类 而StringBuilder就不是线程安全的类\r\n\r\nArrayList是非线程安全的，换句话说，多个线程可以同时进入一个ArrayList对象的add方法\r\n\r\n借助Collections.synchronizedList，可以把ArrayList转换为线程安全的List\r\n\r\n与此类似的，还有HashSet,LinkedList,HashMap等等非线程安全的类，都通过工具类Collections转换为线程安全的\r\n\r\npublic static void main(String[] args) {  List<Integer> list1 = new ArrayList<>();  List<Integer> list2 = Collections.synchronizedList(list1); }\r\n\r\nJVM内存\r\n\r\n程序计数器是一个比较小的内存区域，用于指示当前线程所执行的字节码执行到了第几行，是线程隔离的\r\n\r\n虚拟机栈描述的是Java方法执行的内存模型，用于存储局部变量，操作数栈，动态链接，方法出口等信息，是线程隔离的\r\n\r\n在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等，是线程共享的\r\n\r\n原则上讲，所有的对象都在堆区上分配内存，是线程共享的\r\n\r\nJVM初始运行的时候都会分配好 Method Area（方法区） 和Heap（堆） ，而JVM 每遇到一个线程，就为其分配一个 Program Counter Register（程序计数器） , VM Stack（虚拟机栈）和Native Method Stack （本地方法栈）， 当线程终止时，三者（虚拟机栈，本地方法栈和程序计数器）所占用的内存空间也会被释放掉。这也是为什么我把内存区域分为线程共享和非线程共享的原因，非线程共享的那三个区域的生命周期与所属线程相同，而线程共享的区域与JAVA程序运行的生命周期相同，所以这也是系统垃圾回收的场所只发生在线程共享的区域（实际上对大部分虚拟机来说知发生在Heap上）的原因\r\n\r\nJVM堆分为：新生代（一般是一个Eden区，两个Survivor区），老年代（old区），常量池属于 PermGen（方法区）\r\n关键字\r\n\r\n这个关键字常见的坑：\r\n\r\ntrue、false、null都不是关键字\r\n\r\ngoto、const是保留的关键字\r\n\r\nabstract         continue           for            new  switch          default            if          package synchronized     do            goto           private this         break          double         implements  protected     throw              byte           else    import          public             throws         case enum                    instanceof         return         transient  catch                   extends            int            short  try                     char               final          interface  static                  void               class          finally  long                    strictfp           volatile       const  float                   native             super          while boolean                 assert \r\n\r\nJVM垃圾回收\r\n\r\n两个最基本的java回收算法：复制算法和标记清理算法\r\n\r\n复制算法：两个区域A和B，初始对象在A，继续存活的对象被转移到B。此为新生代最常用的算法\r\n\r\n标记清理：一块区域，标记可达对象（可达性分析），然后回收不可达对象，会出现碎片，那么引出\r\n\r\n标记-整理算法：多了碎片整理，整理出更大的内存放更大的对象\r\n\r\n两个概念：新生代和年老代\r\n\r\n新生代：初始对象，生命周期短的\r\n\r\n永久代：长时间存在的对象\r\n\r\n整个java的垃圾回收是新生代和年老代的协作，这种叫做分代回收\r\n\r\nP.S：Serial New收集器是针对新生代的收集器，采用的是复制算法\r\n\r\nParallel New（并行）收集器，新生代采用复制算法，老年代采用标记整理\r\n\r\nParallel Scavenge（并行）收集器，针对新生代，采用复制收集算法\r\n\r\nSerial Old（串行）收集器，新生代采用复制，老年代采用标记整理Parallel Old（并行）收集器，针对老年代，标记整理\r\n\r\nCMS收集器，基于标记清理\r\n\r\nG1收集器：整体上是基于标记整理，局部采用复制\r\n注解\r\n\r\nOverride注解：\r\n\r\n指明被注解的方法需要覆写超类中的方法.\r\n\r\n如果某个方法使用了该注解,却没有覆写超类中的方法(比如大小写写错了,或者参数错了,或者是子类自己定义的方法),编译器就会生成一个错误.\r\n\r\nDeprecated注解：\r\n\r\n可以修饰类、方法、变量，在java源码中被@Deprecated修饰的类、方法、变量等表示不建议使用的，可能会出现错误的，可能以后会被删除的类、方法等，如果现在使用，则在以后使用了这些类、方法的程序在更新新的JDK、jar包等就会出错，不再提供支持。个人程序中的类、方法、变量用@Deprecated修饰同样是不希望自己和别人在以后的时间再次使用此类、方法。 当编译器编译时遇到了使用@Deprecated修饰的类、方法、变量时会提示相应的警告信息。\r\n\r\nSuppresswarnings注解：\r\n\r\n可以达到抑制编译器编译时产生警告的目的，但是很不建议使用@SuppressWarnings注解，使用此注解，编码人员看不到编译时编译器提示的相应的警告，不能选择更好、更新的类、方法或者不能编写更规范的编码。同时后期更新JDK、jar包等源码时，使用@SuppressWarnings注解的代码可能受新的JDK、jar包代码的支持，出现错误，仍然需要修改。\r\n\r\n抑制警告的关键字：\r\n关键字 \t用途\r\nall \tto suppress all warnings 禁止所有警告\r\nboxing \tto suppress warnings relative to boxing/unboxing operations 抑制与装箱/拆箱操作相关的警告\r\ncast \tto suppress warnings relative to cast operations 抑制与强制转换操作相关的警告\r\ndep-ann \tto suppress warnings relative to deprecated annotation 抑制与已弃用注释相关的警告\r\ndeprecation \tto suppress warnings relative to deprecation\r\nfallthrough \tto suppress warnings relative to missing breaks in switch statements\r\nfinally \tto suppress warnings relative to finally block that don’t return\r\nhiding \tto suppress warnings relative to locals that hide variable\r\nincomplete-switch \tto suppress warnings relative to missing entries in a switch statement (enum case)\r\nnls \tto suppress warnings relative to non-nls string literals\r\nnull \tto suppress warnings relative to null analysis\r\nrawtypes \tto suppress warnings relative to un-specific types when using generics on class params\r\nrestriction \tto suppress warnings relative to usage of discouraged or forbidden references\r\nserial \tto suppress warnings relative to missing serialVersionUID field for a serializable class\r\nstatic-access \to suppress warnings relative to incorrect static access\r\nsynthetic-access \tto suppress warnings relative to unoptimized access from inner classes\r\nunchecked \tto suppress warnings relative to unchecked operations\r\nunqualified-field-access \tto suppress warnings relative to field access unqualified\r\nunused \tto suppress warnings relative to unused code\r\nforward和redirect\r\n\r\nforward，服务器获取跳转页面内容传给用户，用户地址栏不变 redirect，是服务器向用户发送转向的地址，redirect后地址栏变成新的地址\r\n\r\n1.从地址栏显示来说\r\n\r\nforward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址. redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.\r\n\r\n2.从数据共享来说\r\n\r\nforward:转发页面和转发到的页面可以共享request里面的数据. redirect:不能共享数据.\r\n\r\n3.从运用地方来说\r\n\r\nforward:一般用于用户登陆的时候,根据角色转发到相应的模块. redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.\r\n\r\n4.从效率来说\r\n\r\nforward:高. redirect:低.\r\ntry catch\r\n\r\n一旦在finally块中使用了return或throw语句，将会导致try块，catch块中的return，throw语句失效\r\nnative\r\n\r\nnative是由调用本地方法库（如操作系统底层函数），可以由C，C++实现\r\ncount = count++\r\n\r\ncount = count++ 原理是 temp = count； count = count+1 ； count = temp； 因此count始终是0 这仅限于java 与c是不一样的\r\nthrow和throws\r\n\r\n1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理。\r\nJava调试器\r\n\r\njava.exe是java虚拟机\r\n\r\njavadoc.exe用来制作java文档\r\n\r\njdb.exe是java的调试器\r\n\r\njavaprof.exe是剖析工具\r\nHash冲突\r\n\r\nthreadlocalmap使用开放定址法解决hash冲突，hashmap使用链地址法解决hash冲突\r\n字符集编码和国际化\r\n\r\nJava一律采用Unicode编码方式，每个字符无论中文还是英文字符都占用2个字节\r\n\r\n不同的编码之间是可以转换的，通常流程如下：\r\n\r\n将字符串S以其自身编码方式分解为字节数组，再将字节数组以你想要输出的编码方式重新编码为字符串\r\n\r\n例：String newUTF8Str = new String(oldGBKStr.getBytes(\"GBK\"), \"UTF8\");\r\n\r\nJava虚拟机中通常使用UTF-16的方式保存一个字符\r\n\r\nResourceBundle能够依据Local的不同，选择性的读取与Local对应后缀的properties文件，以达到国际化的目的\r\nthis()和super()\r\n\r\n    构造器中第一行默认是super()，一旦直接父类的构造器中没有无参的，那么必须显式调用父类的某个有参构造\r\n\r\n    构造器中第一行的super()可以换成this()，但是this()和super()只能出现一个\r\n\r\n    super，this关键字与super()，this()不是一回事，前者表示当前调用者的父类与其本身，后者是为了构造器相互调用\r\n\r\n    this()和super()都指的是对象，所以，均不可以在static环境中使用。包括：static变量,static方法，static语句块(里面不能使用非static类型的) \r\n\r\n实例变量\r\n\r\n实例变量指的是类中定义的变量，即成员变量，如果没有初始化，会有默认值；局部变量指的是在方法中定义的变量，必须初始化\r\n\r\n类变量指的是用static修饰的属性\r\n运行时异常\r\n\r\n运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常\r\nSocket\r\n\r\n//server ServerSocket server = new ServerSocket(port); Socket socket = server.accept(); InputStream inputStream = socket.getInputStream(); inputStream.close(); socket.close(); server.close();  //client Socket socket = new Socket(host, port); socket.getOutputStream(); outputStream.close(); socket.close();\r\n\r\nString StringBuffer StringBuilder\r\n\r\n    是否可变 \r\n\r\nprivate final char value[];\r\n\r\nString 为不可变对象,一旦被创建,就不能修改它的值. . 对于已经存在的String对象的修改都是重新创建一个新的对象,然后把新的值保存进去.\r\n\r\nStringBuilder与StringBuffer都继承自AbstractStringBuilder类，在AbstractStringBuilder中也是使用字符数组保存字符串，如下就是，可知这两种对象都是可变的。\r\n\r\nchar[] value;\r\n\r\n    是否多线程安全\r\n\r\n    String中的对象是不可变的，也就可以理解为常量， 显然线程安全 。\r\n\r\n    AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。\r\n\r\n    StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是 线程安全的 。\r\n\r\n    StringBuilder并没有对方法进行加同步锁，所以是 非线程安全的 。\r\n\r\n    共同点\r\n\r\n    StringBuilder与StringBuffer有公共父类AbstractStringBuilder( 抽象类 )。\r\n\r\n    抽象类与接口的其中一个区别是：抽象类中可以定义一些子类的公共方法，子类只需要增加新的功能，不需要重复写已经存在的方法；而接口中只是对方法的申明和常量的定义。\r\n\r\n    StringBuilder、StringBuffer的方法都会调用AbstractStringBuilder中的公共方法，如super.append(...)。只是StringBuffer会在方法上加synchronized关键字，进行同步。\r\n\r\n    最后，如果程序不是多线程的，那么使用StringBuilder效率高于StringBuffer。 \r\n\r\n线程公有、线程私有\r\n\r\n私有:java虚拟机栈，程序计数器，本地方法栈 共享:java堆，方法区\r\nOutOfMemoryError\r\n\r\njava.lang.OutOfMemoryError: PermGen space\r\n\r\n属于运行时常量池导致的溢出，设置-XX：MaxPermSize可以解决这个问题\r\n\r\njava.lang.OutOfMemoryError: Requested array size exceeds VM limit\r\n\r\njava.lang.OutOfMemoryError: Java heap space\r\n\r\n属于java堆内存问题，一般的手段是通过内存映像分析工具，对Dump出来的堆转储存快照进行分析，重点是确认内存中的对象是否是有必要的，也就是要判断是出现了内存泄漏，还是出现了内存溢出，如果是内存列楼，通过工具检查泄露对象打GC Roots的引用链信息，可以准确的确定出泄露代码的位置，不存在泄露，就应该检查虚拟机的堆参数，如果可以继续调大，可以设置-Xmx解决问题\r\n\r\njava.lang.OutOfMemoryError: nativeGetNewTLA\r\n\r\n指当虚拟机不能分配新的线程本地空间(Thread Local Area）的时候错误信息，此错误是线程申请一个新的TLA时产生的，这个异常一般只会发生在jRockit虚拟机，只有过于绝对\r\n重写方法\r\n\r\n两同两小一大原则\r\n\r\n    两同：方法名和参数列表相同\r\n\r\n    两小：返回值或声明异常比父类小（或相同）\r\n\r\n    一大：访问修饰符比父类的大（或相同） \r\n\r\nqueue\r\n\r\nLinkedBlockingQueue是一个可选有界队列，不允许null值\r\n\r\nLinkedBlockingQueue是一个线程安全的阻塞队列，实现了先进先出等特性\r\n\r\nPriorityQueue是一个无界队列，不允许null值，入队和出队的时间复杂度是O（log(n)）\r\n\r\nConcurrentLinkedQueue是一个基于链接节点的线程安全队列，该队列的元素遵循FIFO原则\r\nSet\r\n\r\nTreeSet使用二叉树对元素进行排序，使用二叉树的原理对新 add()的对象按照指定的顺序排序（升序、降序），每增加一个对象都会进行排序，将对象插入的二叉树指定的位置。\r\n\r\nLinkedHashSet 继承于HashSet，又基于 LinkedHashMap 来实现。\r\n\r\nHashSet 存储元素的顺序并不是按照存入时的顺序（和 List 显然不同） 而是按照哈希值来存的所以取数据也是按照哈希值取得 。\r\n\r\nSet 是继承于Collection的接口。它是一个不允许有重复元素的集合。AbstractSet 是一个抽象类，它继承于AbstractCollection。AbstractCollection实现了Set中的绝大部分函数，为Set的实现类提供了便利。HastSet 和 TreeSet 是Set的两个实现类。HashSet依赖于HashMap，它实际上是通过HashMap实现的。HashSet中的元素是无序的。TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。TreeSet中的元素是有序的。LinkedHashSet继承于HashSet，是具有可预知迭代顺序的 Set 接口的哈希表和链接列表实现。此实现与 HashSet 的不同之外在于，后者维护着一个运行于所有条目的双重链接列表。此链接列表定义了迭代顺序，即按照将元素插入到 set 中的顺序（插入顺序）进行迭代。\r\nRuntimeException\r\n\r\nRuntimeException并不必须被捕获。不管异常代表的是可预见的异常条件还是编程错误，如果用try{}catch语句捕获它，会让程序在已经出现错误的情况下继续执行下去，也就是说我们不会及时的察觉到程序出现的问题。如果我们不去处理RuntimeException，让程序在测试阶段把异常传播给外界，这时系统打印出来的调用堆栈路径可以帮助我们更快的找出并修改错误，避免出现更大的损失。\r\n\r\n通常，Java的异常(包括Exception和Error)分为可查的异常（checked exceptions）和不可查的异常（unchecked exceptions）\r\n\r\n可查异常（编译器要求必须处置的异常）： 正确的程序在运行中，很容易出现的、情理可容的异常状况 。 可查异常虽然是异常状况，但在一定程度上它的发生是可以预计的，而且一旦发生这种异常 状况，就必须采取某种方式进行处理。\r\n\r\n除了RuntimeException及其子类以外，其他的Exception类及其子类都属于可查异常。这种异常的特点是Java编译器会检查它，也就是说，当程序中可能出现这类异常，要么用try-catch语句捕获它，要么用throws子句声明抛出它，否则编译不会通过。\r\n\r\n不可查异常(编译器不要求强制处置的异常):包括运行时异常（RuntimeException与其子类）和错误（Error）。\r\n\r\nException 这种异常分两大类运行时异常和非运行时异常(编译异常)。程序中应当尽可能去处理这些异常。\r\n\r\n运行时异常：都是RuntimeException类及其子类异常，如NullPointerException(空指针异常)、IndexOutOfBoundsException(下标越界异常)等，这些异常是不检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。\r\n\r\n运行时异常的特点是Java编译器不会检查它，也就是说，当程序中可能出现这类异常，即使没有用try-catch语句捕获它，也没有用throws子句声明抛出它，也会编译通过。\r\n\r\n非运行时异常 （编译异常）：是RuntimeException以外的异常，类型上都属于Exception类及其子类。从程序语法角度讲是必须进行处理的异常，如果不处理，程序就不能编译通过。如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。\r\n线程安全的Map\r\n\r\nHashTable, SynchronizedMap, ConcurrentHashMap\r\nJava表达式转型规则\r\n\r\nJava表达式转型规则由低到高转换：\r\n\r\n    所有的byte,short,char型的值将被提升为int型\r\n\r\n    如果有一个操作数是long型，计算结果是long型\r\n\r\n    如果有一个操作数是float型，计算结果是float型\r\n\r\n    如果有一个操作数是double型，计算结果是double型\r\n\r\n    被final修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化 \r\n\r\n字节流字符流\r\n\r\n字节流：\r\n\r\nInputStream |-- FileInputStream (基本文件流） |-- BufferedInputStream |-- DataInputStream\r\n\r\n|-- ObjectInputStream\r\n\r\n字符流\r\n\r\nReader |-- InputStreamReader (byte->char 桥梁） |-- BufferedReader (常用） Writer |-- OutputStreamWriter (char->byte 桥梁） |-- BufferedWriter |-- PrintWriter （常用）\r\n多态的作用\r\n\r\n提高可重用性 扩展代码模块\r\nSpring配置\r\n\r\nSpring本身并不直接管理事务，而是提供了事务管理器接口，对于不同的框架或者数据源则用不同的事务管理器；而对于事务，它把相关的属性都封装到一个实体里面去，有以下的属性：\r\n\r\nint propagationBehavior; // 事务的传播行为 int isolationLevel; // 事务的隔离级别 int timeout; // 事务完成的最短时间 boolean readOnly; // 是否只读\r\n\r\nSpring提供了对编程式事务和声明式事务的支持，编程式事务是嵌在业务代码中的，而声明式事务是基于xml文件配置。\r\nreadOnly \t事务隔离级别，表示只读数据，不更新数据\r\nPROPAGATION_REQUIRED \t支持当前事务，如果当前没有事务，就新建一个事务\r\nPROPAGATION_SUPPORTS \t支持当前事务，如果当前没有事务，就以非事务方式执行\r\nPROPAGATION_REQUIRES_NEW \t新建事务，如果当前存在事务，把当前事务挂起\r\nPROPAGATION_MANDATORY \t支持当前事务，如果当前没有事务，就抛出异常\r\nPROPAGATION_NOT_SUPPORTED \t以非事务方式执行操作，如果当前存在事务，就把当前事务挂起\r\nPROPAGATION_NEVER \t以非事务方式执行，如果当前存在事务，则抛出异常\r\nhashCode\r\n\r\nhashCode方法本质就是一个哈希函数，这是Object类的作者说明的。Object类的作者在注释的最后一段的括号中写道：将对象的地址值映射为integer类型的哈希值。但hashCode()并不完全可靠的，有时候不同的对象他们生成的hashcode也会一样，因此hashCode()只能说是大部分时候可靠。因此我们也需要重写equals()方法，但因为重写的equals()比较全面比较复杂，会造成程序效率低下，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。因此，正常的操作流程是先用hashCode()去对比两个对象，如果hashCode()不一样，则表示这两个对象肯定不相等，直接返回false,如果hashCode()相同，再对比他们的equals()\r\n\r\n综上所述：equals()相等的两个对象hashCode()一定相等。hashCode()相等的两个对象equal()不一定相等。\r\n导包\r\n\r\n导包只可以导到当前层，不可以再导入包里面的包中的类\r\n\r\njava.awt.*是导入java\\awt包下所有的类，并不包括其子包下的类\r\n\r\njava.awt.event.才能导入java\\awt\\event包下的类\r\nJava体系结构\r\n\r\nJava体系结构包括四个独立但相关的技术：\r\n\r\n    Java程序设计语言\r\n\r\n    Java.class文件格式\r\n\r\n    Java应用编程接口（API）\r\n\r\n    Java虚拟机 \r\n\r\n线程方法\r\n\r\n启动线程是调用start方法，把线程的run方法当普通方法，就直接用实例.run()执行就好了\r\n\r\n没有看到start，所以是普通方法调用\r\n重写和重载\r\n\r\n重载和重写都是多态的一种体现方式，重载是编译期间的活动，重写是运行期间的活动\r\n\r\n重载是在一个类中定义相同的名字的方法，方法的参数列表或者类型要互相不同，但是返回值类型不作为是否重载的标准，可以修改可见性； 重写是不同的，要求子类重写基类的方法时要与父类方法具有相同的参数类型和返回值，可见性需要大于等于基类的方法\r\n数组length()\r\n\r\njava的String底层是char数组，它的length()返回数组大小，而unicode中一个汉字是可以用一个char表示的\r\n多继承\r\n\r\nJava只支持单继承，实现多重继承三种方式：（1）直接实现多个接口 （2）扩展(extends)一个类然后实现一个或多个接口 （3）通过内部类去继承其他类\r\n内部类\r\n\r\n    静态内部类\r\n\r\n        静态内部类本身可以访问外部的静态资源，包括静态私有资源，但是不能访问非静态资源，可以不依赖外部类实例而实例化 \r\n\r\n    成员内部类\r\n\r\n        成员内部类本身可以访问外部的所有资源，但是自身不能定义静态资源，因为其实例化本身就还依赖着外部类 \r\n\r\n    局部内部类\r\n\r\n        局部内部类就像一个局部方法，不能被访问修饰符修饰，也不能被static修饰\r\n\r\n        局部内部类只能访问所在代码块或者方法中被定义为final的局部变量 \r\n\r\n    匿名内部类\r\n\r\n        没有类名的内部类，不能使用class，extends和implements，没有构造方法\r\n\r\n        多用于GUI中的事件处理\r\n\r\n        不能定义静态资源\r\n\r\n        只能创建一个匿名内部类实例\r\n\r\n        一个匿名内部类一定是在new后面的，这个匿名类必须继承一个父类或者实现一个接口\r\n\r\n        匿名内部类是局部内部类的特殊形式，所以局部内部类的所有限制对匿名内部类也有效 \r\n\r\n类之间的关系\r\n\r\nUSES-A：依赖关系，A类会用到B类，这种关系具有偶然性，临时性。但B类的变化会影响A类。这种在代码中的体现为：A类方法中的参数包含了B类。\r\n\r\n关联关系：A类会用到B类，这是一种强依赖关系，是长期的并非偶然。在代码中的表现为：A类的成员变量中含有B类。\r\n\r\nHAS-A：聚合关系，拥有关系，是关联关系的一种特例，是整体和部分的关系。比如鸟群和鸟的关系是聚合关系，鸟群中每个部分都是鸟。\r\n\r\nIS-A：表示继承。父类与子类，这个就不解释了。\r\n\r\n要注意：还有一种关系：组合关系也是关联关系的一种特例，它体现一种contains-a的关系，这种关系比聚合更强，也称为强聚合。它同样体现整体与部分的关系，但这种整体和部分是不可分割的。\r\n\r\n\r\n",
      "data": {
        "title": "Java八股文",
        "date": "2022-10-19 12:31:59",
        "tags": [
          "Java"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "Java"
    },
    {
      "content": "![](https://ethic-233.github.io/post-images/1666155491360.jpeg)INSERT\r\n\r\n在使用insert语句插入数据时，表达式的数据类型和表格中对应各列的数据类型不一定需要一致\r\n\r\n答: 必须完全一致\r\nALTER TABLE\r\n\r\n这个语句用于对数据库表本身进行操作，包括添加删除修改列，添加删除修改主键、外键等\r\ngetdate/now\r\n\r\n获取当前时间，包括年月日时分秒，格式 yyyy-mm-dd HH:mm:ss\r\n\r\ngetdate() 是SqlServer的函数\r\n\r\nnow() 是 mysql的函数\r\ndatediff\r\n\r\nDATEDIFF() 函数返回两个日期之间的时间。\r\n\r\n这个函数是sqlsever的函数\r\n脏读\r\n\r\n对于两个事务T1，T2，T1读取了已经被T2更新但还没有被提交的字段，之后，若T2回滚，T1读取的内容就是临时且无效\r\nDROP TABLE User;\r\n\r\n有一个User用户表，现要删除整张表（指完全删除表数据和表结构）\r\nCOUNT()函数\r\n\r\n1.count()函数是用来统计表中记录的一个函数，返回匹配条件的行数。\r\n\r\n2.count()语法：\r\n\r\n（1）count(*)---包括所有列，返回表中的记录数，相当于统计表的行数，在统计结果的时候，不会忽略列值为NULL的记录。\r\n\r\n（2）count(1)---忽略所有列，1表示一个固定值，也可以用count(2)、count(3)代替，在统计结果的时候，不会忽略列值为NULL的记录。\r\n\r\n（3）count(列名)---只包括列名指定列，返回指定列的记录数，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。\r\n\r\n（4）count(distinct 列名)---只包括列名指定列，返回指定列的不同值的记录数，在统计结果的时候，在统计结果的时候，会忽略列值为NULL的记录（不包括空字符串和0），即列值为NULL的记录不统计在内。\r\nSELECT * INTO\r\n\r\nselect * into seniordrivers from drivers where drivedistanced >=5000\r\n\r\n某打车公司要将驾驶里程（drivedistanced）超过5000里的司机信息转存到一张称为seniordrivers 的表中，他们的详细情况被记录在表drivers 中\r\n视图\r\n\r\n视图是从一个或几个基本表（或视图）中导出的虚拟的表。在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。\r\n\r\n视图是原始数据库数据的一种变换，是查看表中数据的另外一种方式。可以将视图看成是一个移动的窗口，通过它可以看到感兴趣的数据。 视图是从一个或多个实际表中获得的，这些表的数据存放在数据库中。那些用于产生视图的表叫做该视图的基表。一个视图也可以从另一个视图中产生。\r\n\r\n视图的定义存在数据库中，与此定义相关的数据并没有再存一份于数据库中。通过视图看到的数据存放在基表中。\r\n\r\n视图看上去非常像数据库的物理表，对它的操作同任何其它的表一样。当通过视图修改数据时，实际上是在改变基表中的数据；相反地，基表数据的改变也会自动反映在由基表产生的视图中。由于逻辑上的原因，有些视图可以修改对应的基表，而有些则不能（仅仅能查询）。\r\nHAVING\r\n\r\nWHERE 关键字无法与聚合函数一起使用， 筛选分组后的各组数据用HAVING\r\n修改字段\r\n\r\nCHANGE 用来修改字段名字以及类型\r\n\r\nmodify 用来修改字段类型\r\n\r\naiter column ... set 用来修改字段数据\r\n\r\n\r\n",
      "data": {
        "title": "MySQL",
        "date": "2022-10-19 12:30:15",
        "tags": [
          "MySQL"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "mysql"
    },
    {
      "content": "![](https://ethic-233.github.io/post-images/1666155504315.gif)# 为什么用\r\n\r\n用缓存技术来缓解数据库压力，优化数据库的结构和索引，Memcached只能缓解数据库的读取压力，master-slave模式使用主从复制技术来达到读写分离，提高读写性能和读库的可扩展性。在Memcached的高速缓存，MySQL的主从复制，读写分离的基础之上，MySQL主库的写压力开始出现瓶颈，而数据量的持续猛增，由于`MyISAM`使用表锁，在高并发下会出现严重的锁问题，大量的高并发MySQL应用开始使用`InnoDB`引擎代替`MyISAM`，同时，开始流行使用分表分库来缓解写压力和数据增长的扩展问题。\r\n\r\nMySQL数据库也经常存储一些大文本字段，导致数据库表非常大，在做数据库恢复的时候非常慢，不容易快速恢复数据库，扩展性差，大数据下IO压力大，表结构更改困难。\r\n\r\n今天我们可以通过第三方平台可以很容易的访问和抓取数据。用户的个人信息、社交网络、地理位置，用户生成的数据和用户操作日志已经成倍增加。如果要对这些用户数据进行挖掘，那SQL数据库已经不适合这些应用了，NoSQL数据库的发展却能很好的处理这些大的数据。\r\n\r\n`NoSQL(NoSQL = Not Only SQL)`，意即\"不仅仅是SQL\"\r\n\r\n泛指非关系型数据库，为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用难题，包括超大规模数据的存储。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。NoSQL数据库种类繁多，但是一个共同的特点都是去掉关系数据库的关系型特性。数据之间无关系，这样就非常容易扩展，无形之间在架构层面带来了可扩展的能力。\r\n\r\n一般MySQL使用Query Cache，每次表的更新Cache就失效，是一种大粒度的Cache，在针对web2.0的交互频繁的应用，Cache性能不高，而NoSQL的Cache是记录级的，是一种细粒度的Cache，所以NoSQL在这个层面上来说性能高多了。\r\n\r\n多样灵活的数据模型：NoSQL无需事先为要存储的数据建立字段，随时可以存储自定义的数据格式，而在关系数据库里，增删字段是一件非常麻烦的事。\r\n\r\nNoSQL\r\n\r\n- 代表不仅仅是SQL\r\n- 没有声明性查询语言\r\n- 没有预定义的模式\r\n- 键值对存储，列存储，文档存储，图形数据库\r\n- 最终一致性，而非ACID属性\r\n- 非结构化和不可预知的数据\r\n- CAP定理\r\n- 高性能，高可用性和可伸缩性\r\n\r\nMongoDB是一个基于分布式文件存储的数据库，由C++语言编写，旨在为WEB应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\r\n\r\n四大分类\r\n\r\n- KV键值\r\n- 文档型数据库\r\n- 图关系数据库：它不是放图形的，放的是关系比如朋友圈社交网络、广告推荐系统、专注于构建关系图谱，Neo4J，`InfoGrid`\r\n\r\nCAP原理\r\n\r\n- 传统的ACID分别是什么\r\n\r\n- CAP\r\n\r\n  - C：Consistency（强一致性）\r\n  - A：Availablity（可用性）\r\n  - P：Partition tolerance（分区容错性）\r\n\r\n- CAP的3进2\r\n\r\n  CAP理论是说在分布式存储系统中，最多只能实现上面的两点，而由于当前的网络硬件肯定会出现延迟丢包等问题，所以，分区容忍性是我们必须实现的。所以我们只能在一致性和可用性之间进行权衡，没有NoSQL系统能同时保证这三点。\r\n\r\n  C：强一致性\r\n\r\n  A：高可用性\r\n\r\n  P：分布式容忍性\r\n\r\n  CA：传统Oracle数据库\r\n\r\n  AP：大多数网站架构的选择\r\n\r\n  CP：Redis，MongoDB\r\n\r\n  注意：分布式架构的时候必须做出取舍\r\n\r\n- 经典CAP图\r\n\r\n  CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。\r\n\r\n  因此，根据CAP原理将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类。\r\n\r\n  - CA：单点集群，满足一致性、可用性的系统，通常在可扩展性上不太强大\r\n  - CP：满足一致性、分区容忍性的系统，通常性能不是特别高\r\n  - AP：满足可用性、分区容忍性的系统，通常可能对一致性要求低一些\r\n\r\n- BASE\r\n\r\n  BASE是为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案。\r\n\r\n  BASE其实是下面三个术语的缩写\r\n\r\n  - 基本可用（`Basically Available`）\r\n  - 软状态（`Soft state`）\r\n  - 最终一致（`Eventually consistent`）\r\n\r\n  它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观，因为大型系统往往由于地域分布和极高性能的要求，不可能采用分布式事务来完成这些指标，要想获得这些指标，我们必须采用另一种方式来完成，这里BASE就是解决这个问题的办法。\r\n\r\n- 分布式+集群简介\r\n\r\n`Redis：REmote DIctionary Server(远程字典服务器)`\r\n\r\n是完全开源免费的，用C语言编写的，遵守BSD协议，是一个高性能的（`key/value`）分布式内存数据库，基于内存运行，并支持持久化的NoSQL数据库，是当前最热门的NoSQL数据库之一，也被人们称为数据结构服务器。\r\n\r\nRedis与其他key-value缓存产品有以下三个特点\r\n\r\n- Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。\r\n- Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，`zset`，hash等数据结构的存储。\r\n- Redis支持数据的备份，即master-slave模式的数据备份。\r\n\r\n能干嘛\r\n\r\n- 内存存储和持久化：`redis`支持异步将内存中的数据写到硬盘上，同时不影响继续服务。\r\n- 取最新N个数据的操作，如：可以将最新的10条评论的ID放在Redis的List集合里面。\r\n- 模拟类似于`HttpSession`这种需要设定过期时间的功能\r\n- 发布、订阅消息系统\r\n- 定时器、计数器\r\n\r\n# 基本知识\r\n\r\n- 单进程\r\n  - 单进程模型来处理客户端的请求、对读写等事件的响应是通过对epoll函数的包装来做到的，Redis的实际处理速度完全依靠主进程的执行效率\r\n  - Epoll是Linux内核为处理大批量文件描述符而作了改进的epoll，是Linux下多路复用IO接口select/poll的增强版本，它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率\r\n- 默认16个数据库，类似数组下标从零开始，初始默认使用零号库\r\n- Select命令切换数据库\r\n- Dbsize查看当前数据库的key的数量\r\n- Flushdb：清空当前库\r\n- Flushall：通杀全部库\r\n- 统一密码管理，16个库都是同样密码，要么都OK要么一个也连接不上\r\n- Redis索引都是从0开始\r\n- 为什么默认端口是6379\r\n\r\n# 数据类型\r\n\r\n- 五大数据类型\r\n\r\n  - String（字符串）\r\n  - Hash（哈希，类似Java里的Map）\r\n  - List（列表）\r\n  - Set（集合）\r\n  - Zset（sorted set：有序集合）\r\n\r\n- 哪里去获得redis常见数据类型操作命令\r\n\r\n- 键（key）\r\n\r\n  - `keys *`\r\n  - `exist key的名字`，判断某个key是否存在\r\n  - `move key db`，移除当前库\r\n  - `expire key 秒钟`，为给定的key设置过期时间\r\n  - `ttl key`，查看还有多少秒过期，-1表示永不过期，-2表示已经过期\r\n  - `type key`，查看你的key是什么类型\r\n\r\n- 字符串（String）\r\n\r\n  String是redis最基本的类型，你可以理解成与Memcached一模一样的类型，一个key对应一个value\r\n\r\n  String类型是二进制安全的，意思是redis的String可以包含任何数据，比如jpg图片或者序列化的对象\r\n\r\n  String类型是Redis最基本的数据类型，一个Redis中字符串value最多可以是512M\r\n\r\n  - 单值单value\r\n  - `set/get/del/append/strlen`\r\n  - `Incr/decr/incrby/decrby`，一定要是数字才能加减\r\n  - `getrange/setrange`\r\n  - `setex(set with expire)`键秒值`/setnx(set if not exist)`\r\n  - `mset/mget/msetnx`\r\n  - `getset(先get再set)`\r\n\r\n- 列表（List）\r\n\r\n  Redis列表是简单的字符串列表，按照插入顺序排序，你可以添加一个元素到列表的头部（左边）或者尾部（右边），它的底层是个链表\r\n\r\n  - 是个字符串链表，left，right都可以插入添加\r\n  - 如果键不存在，创建新的链表；如果键已存在，新增内容；如果键全部移除，对应的键也消失了；头和尾操作效率高\r\n\r\n- 集合（Set）\r\n\r\n  Redis的Set是string类型的无序集合，它是通过HashTable实现的\r\n\r\n  - 单值多value\r\n  - `sadd/smembers/sismember`\r\n  - `scard`，获取集合里面的元素个数\r\n  - `srem key value`，删除集合中元素\r\n  - `srandmember key`，某个整数（随机出几个数）\r\n  - `spop key`，随机出栈\r\n  - `smove key1 key2`，在key里某个值，作业是将key1里的某个值赋给key2\r\n  - 数学集合类\r\n    - 差集：sdiff\r\n    - 交集：sinter\r\n    - 并集：sunion\r\n\r\n- 哈希（Hash）\r\n\r\n  是一个键值对集合，是一个String类型的field和value的映射表，hash特别适合用于存储对象，类似于Java的Map<String，Object>\r\n\r\n  - KV模式不变，但V是个键值对\r\n  - `hset/hget/hmset/hmget/hgetall/hdel`\r\n  - `hlen`\r\n  - `hexist key`，在key里面的某个值的key\r\n  - `hkeys/hvals`\r\n  - `hincrby/hincrbyfloat`\r\n  - `hsetnx`\r\n\r\n- 有序集合Zset（sorted set）\r\n\r\n  Redis Zset和set一样也是String类型元素的集合，且不允许重复的成员\r\n\r\n  不同的是每个元素都会关联一个double类型的分数\r\n\r\n  Redis正是通过分数来为集合中的成员进行从小到大的排序，zset的成员是唯一的，但分数（score）却可以重复\r\n\r\n  - 在set基础上加一个score值，之前set是k1 v1 v2 v3\r\n\r\n    现在zset是k1 score1 v1 score2 v2\r\n\r\n  - `zadd/zrange`\r\n\r\n  - `zrangebyscore key`，开始score，结束score\r\n\r\n    - `withscores`\r\n    - `(`，不包含\r\n    - `Limit`，作用是返回限制，Limit开始下标步，多少步\r\n\r\n  - `zrem key`，某score下对应的value值，作用是删除元素\r\n\r\n  - `zcard/zcount key score`区间`zrank key values`值，作用是获得下标值`/zscore key`对应值，获得分数\r\n\r\n  - `zrerank key values`值，作用是逆序获得下标值\r\n\r\n  - `zrevrange`\r\n\r\n  - `zrerangebyscore key`，结束score开始score\r\n\r\n\r\n\r\n",
      "data": {
        "title": "Redis",
        "date": "2022-10-19 12:26:49",
        "tags": [
          "Redis"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "redis"
    },
    {
      "content": "![](https://ethic-233.github.io/post-images/1666155514000.jpg)# 消息队列\r\n\r\n## MQ\r\n\r\n### 什么是MQ\r\n\r\n`MQ(message queue)`，是个队列，FIFO先入先出，只不过队列中存放的是message而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了MQ之后，消息发送上游只需要依赖MQ，不用依赖其他服务。\r\n\r\n### 为什么要用MQ\r\n\r\n1. 流量消耗\r\n\r\n   举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。\r\n\r\n2. 应用解耦\r\n\r\n   以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。\r\n\r\n3. 异步处理\r\n\r\n   有些服务间调用是异步的，例如A调用B，B需要花费很长时间执行，但是A需要知道B什么时候可以执行完，以前一般有两种方式，A过一段时间去调用B的查询`api`查询。或者A提供一个`callback api`,B执行完之后调用`api`通知A服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题,A调用B服务后，只需要监听B处理完成的消息，当B处理完成后，会发送一条消息给MQ，MQ会将此消息转发给A服务。这样A服务既不用循环调用B的查询`api`，用做这些操作。A服务还能及时的得到异步处理成功的消息。\r\n\r\n### MQ的分类\r\n\r\n#### ActiveMQ\r\n\r\n优点：单机吞吐量万级，时效性`ms`级，可用性高，基于主从架构实现高可用性，消息可靠性较低的概率丢失数据。\r\n\r\n缺点：官方社区现在对ActiveMQ 5.x维护越来越少，高吞吐量场景较少使用。\r\n\r\n#### Kafka\r\n\r\n大数据的杀手锏，谈到大数据领域内的消息传输，则绕不开Kafka，这款为大数据而生的消息中间件，以其百万级TPS的吞吐量名声大噪，迅速成为大数据领域的宠儿，在数据采集、传输、存储的过程中发挥着举足轻重的作用。目前已经被LinkedIn，Uber，Twitter，Netflix等大公司所采纳。\r\n\r\n优点：性能卓越，单机写入TPS约在百万条/秒，最大的优点，就是吞吐量高。时效性`ms`级可用性非常高，`kafka`是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用，消费者采用`Pull`方式获取消息，消息有序，通过控制能够保证所有消息被消费且仅被消费一次；有优秀的第三方Kafka Web管理界面Kafka-Manager；在日志领域比较成熟，被多家公司和多个开源项目使用；功能支持：功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用。\r\n\r\n缺点：Kafka单机超过64个队列/分区，Load会发生明显的飙高现象，队列越多，load越高，发送消息响应时间变长，使用短轮询方式，实时性取决于轮询间隔时间，消费失败不支持重试；支持消息顺序，但是一台代理宕机后，就会产生消息乱序，社区更新较慢。\r\n\r\n#### RocketMQ\r\n\r\n`RocketMQ`出自阿里巴巴的开源产品，用Java语言实现，在设计时参考了Kafka，并做出了自己的一些改进。被阿里巴巴广泛应用在订单，交易，充值，流计算，消息推送，日志流式处理，`binglog`分发等场景。\r\n\r\n优点：单机吞吐量十万级，可用性非常高，分布式架构，消息可以做到0丢失，MQ功能较为完善，还是分布式的，扩展性好，支持10亿级别的消息堆积，不会因为堆积导致性能下降，源码是java我们可以自己阅读源码，定制自己公司的MQ。\r\n\r\n缺点：支持的客户端语言不多，目前是java及C++，其中C++不成熟；社区活跃度一般，没有在MQ核心中去实现JMS等接口，有些系统要迁移需要修改大量代码。\r\n\r\n#### RabbitMQ\r\n\r\n2007年发布，是一个在AMQP(高级消息队列协议)基础上完成的，可复用的企业消息系统，是当前最主流的消息中间件之一。\r\n\r\n优点：由于`erlang`语言的高并发特性，性能较好；吞吐量到万级，MQ功能比较完备、健壮、稳定、易用、跨平台、支持多种语言，如: Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX文档齐全；开源提供的管理界面非常棒，用起来很好用，社区活跃度高；更新频率相当高。\r\n\r\n缺点：商业版需要收费,学习成本较高。\r\n\r\n### MQ的选择\r\n\r\n#### `Kafka`\r\n\r\nKafka主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能,肯定是首选Kafka了。\r\n\r\n#### `RocketMQ`\r\n\r\n天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。`RoketMQ`在稳定性上可能更值得信赖，这些业务场景在阿里双11已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择`RocketMQ`。\r\n\r\n#### `RabbitMQ`\r\n\r\n结合erlang语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的RabbitMQ。\r\n\r\n## RabbitMQ\r\n\r\nRabbitMQ是一个消息中间件：它接受并转发消息。你可以把它当做一个快递站点，当你要发送一个包裹时，你把你的包裹放到快递站，快递员最终会把你的快递送到收件人那里，按照这种逻辑RabbitMQ是一个快递站，一个快递员帮你传递快件。RabbitMQ.与快递站的主要区别在于，它不处理快件而是接收，存储和转发消息数据。\r\n\r\n### 四大核心概念\r\n\r\n- 生产者\r\n\r\n  产生数据发送消息的程序是生产者。\r\n\r\n- 交换机\r\n\r\n  交换机是RabbitMQ非常重要的一个部件，一方面它接收来自生产者的消息，另一方面它将消息推送到队列中。交换机必须确切知道如何处理它接收到的消息，是将这些消息推送到特定队列还是推送到多个队列，亦或者是把消息丢弃，这个得由交换机类型决定。\r\n\r\n- 队列\r\n\r\n  队列是RabbitMQ内部使用的一种数据结构，尽管消息流经RabbitMQ和应用程序，但它们只能存储在队列中。队列仅受主机的内存和磁盘限制的约束，本质上是一个大的消息缓冲区。许多生产者可以将消息发送到一个队列，许多消费者可以尝试从一个队列接收数据。这就是我们使用队列的方式。\r\n\r\n- 消费者\r\n\r\n  消费与接收具有相似的含义。消费者大多时候是一个等待接收消息的程序。请注意生产者，消费者和消息中间件很多时候并不在同一机器上。同一个应用程序既可以是生产者又是可以是消费者。\r\n\r\n![图片说明](https://uploadfiles.nowcoder.com/images/20221013/428825176_1665594616855/27435235FA7684FF92CB1E800264346E \"图片标题\") \r\n\r\n### 各个名词介绍\r\n\r\n`Broker`：接收和分发消息的应用，`RabbitMQ Server`就是`Message Broker`\r\n\r\n`Virtual host`：出于多租户和安全因素设计的，把AMQP的基本组件划分到一个虚拟的分组中，类似于网络中的`namespace`概念。当多个不同的用户使用同一个`RabbitMQ server`提供的服务时，可以划分出多个`vhost`，每个用户在自己的`vhost`创建`exchange/queue`等。\r\n\r\n`Connection`：`publisher/consumer`和`broker`之间的TCP连接。\r\n\r\n`Channel`：如果每一次访问`RabbitMQ`都建立一个`Connection`，在消息量大的时候建立`TCP Connection`的开销将是巨大的，效率也低。`Channel`是在connection内部建立的逻辑连接，如果应用程序支持多线程，通常每个thread创建单独的channel进行通讯，`AMQP method`包含了`channel id`帮助客户端和`message broker`识别`channel`，所以`channel`之间是完全隔离的。Channel作为轻量级的Connection极大减少了操作系统建立TCP connection的开销。\r\n\r\n`Exchange`：message到达broker的第一站，根据分发规则，匹配查询表中的`routing key`，分发消息到queue中去。常用的类型有：`direct(point-to-point)`，`topic(publish-subscribe) and fanout(multicast)`\r\n\r\n`Queue`：消息最终被送到这里等待consumer取走\r\n\r\n`Binding`：exchange和queue之间的虚拟连接，binding中可以包含routing key，Binding信息被保存到exchange中的查询表中，用于message的分发依据。\r\n\r\n# 安装，启动\r\n\r\n查找镜像\r\n\r\n```shell\r\ndocker search rabbitmq\r\n```\r\n\r\n拉取镜像\r\n\r\n```shell\r\ndocker pull rabbitmq:3-management\r\n```\r\n\r\n启动镜像\r\n\r\n```shell\r\ndocker run --name rabbitmq  -d -p 5672:5672 -p 15672:15672 镜像ID\r\n```\r\n\r\n# Work Queues\r\n\r\n工作队列（又称任务队列）的主要思想是避免立即执行资源密集型任务，而不得不等待他完成。相反我们安排任务在之后执行。我们把任务封装为消息并将其发送到队列。在后台运行的工作进程将弹出任务并最终执行作业。当有多个工作线程时，这些工作线程将一起处理这些任务。\r\n\r\n# 消息应答\r\n\r\n## 概念\r\n\r\n消费者完成一个任务可能需要一段时间，如果其中一个消费者处理一个长的任务并仅只完成了部分突然它挂掉了，会发生什么情况。RabbitMQ一旦向消费者传递了一条消息，便z即将孩消息标记为删除。在这种情祝下，突然有个消费者挂掉了，我们将丢失正在处理的消息。以及后续发送给该消费这的消息，因为它无法接收到。为了保证消息在发送过程中不丢失，RabbitMQ引入消息应答机制，消息应答就是：消费者在接收到消息并且处理该消息之后，告诉RabbitMQ它已经处理了，RabbitMQ可以把该消息删除了。\r\n\r\n## 自动应答\r\n\r\n消息发送后立即被认为已经传送成功，这种模式需要在高吞吐量和数据传输安全性方面做权衡，因为这种模式如果消息在接收到之前，消费者那边出现连接或者channel关闭，那么消息就丢失了，当然另一方面这种模式消费者那边可以传递过载的消息，没有对传递的消息数量进行限制，当然这样有可能使得消费者这边由于接收太多还来不及处理的消息，导致这些消息的积压，最终使得内存耗尽，最终这些消费者线程被操作系统杀死，所以这种模式仅适用在消费者可以高效并以某种速率能够处理这些消息的情况下使用。\r\n\r\n## 消息应答的方式\r\n\r\n- `Channel.basicAck`（用于肯定确认）\r\n\r\n  `RabbitMQ`已知道该消息并且成功的处理消息，可以将其丢弃了\r\n\r\n- `Channel.basicNack`（用于否定确认）\r\n\r\n- `Channel.basicReject`（用于否定确认）\r\n\r\n  与`Channel.basicNack`相比少一个参数\r\n\r\n  不处理该消息了直接拒绝，可以将其丢弃了\r\n\r\n## Multiple的解释\r\n\r\n手动应答的好处是可以批量应答并且减少网络拥堵。\r\n\r\n```java\r\nchannel.basicAck(deliveryTag, true);\r\n// 如果是true表示批量，如果是false表示不批量\r\n```\r\n\r\n## 消息自动重新入队\r\n\r\n如果消费者由于某些原因失去连接（其通道已关闭，连接已关闭或TCP连接丢失），导致消息未发送ACK确认，RabbitMQ将了解到消息未完全处理，并将其重新排队。如果此时其他消费者可以处理，它将很快将其重新分发给另一个消费者。这样，即使某个消费者偶尔死亡，也可以确保不会丢失任何消息。\r\n\r\n# RabbitMQ持久化\r\n\r\n## 概念\r\n\r\n刚刚我们已经看到了如何处理任务不丢失的情况，但是如何保障当RabbitMQ服务停掉以后消息生产者发送过来的消息不丢失。默认情况下RabbitMQ退出或由于某种原因崩溃时，它忽视队列和消息，除非告知它不要这样做。确保消息不会丢失需要做两件事：我们需要将队列和消息都标记为持久化。\r\n\r\n## 队列如何实现持久化\r\n\r\n之前我们创建的队列都是非持久化的，RabbitMQ如果重启的话，该队列就会被删除掉，如果要队列实现持久化，需要在声明队列的时候把durable参数设置为持久化。\r\n\r\n```java\r\nboolean durable = true;\r\nchannel.queueDeclare(ACK_QUEUE_NAME, durable, false, false, null);\r\n```\r\n\r\n但是需要注意的是如果之前声明的队列不是持久化的，需要把原先队列先删除，或者重新创建一个持久化的队列，不然就会出现错误。\r\n\r\n## 消息实现持久化\r\n\r\n要想让消息实现持久化需要在消息生产者修改代码，`MessageProperties.PERSISTENT_TEXT_PLAIN`添加这个属性。\r\n\r\n把\r\n\r\n```java\r\nchannel.basicPublish(\"\", TASK_QUEUE_NAME, null, message.getBytes(\"UTF-8\"));\r\n```\r\n\r\n改成\r\n\r\n```java\r\nchannel.basicPublish(\"\", TASK_QUEUE_NAME, MessageProperties.PERSISTENT_TEXT_PLAIN, message.getBytes(\"UTF-8\"));\r\n```\r\n\r\n将消息标记为持久化并不能完全保证不会丢失消息。尽管它告诉RabbitMQ。将消息保存到磁盘，但是这里依然存在当消息刚准备存储在磁盘的时候但是还没有存储完，消息还在缓存的一个间隔点。此时并没有真正写入磁盘。持久性保证并不强，但是对于我们的简单任务队列而言，这已经绰绰有余了。\r\n\r\n## 不公平分发\r\n\r\n在最开始的时候我们学习到RabbitMQ分发消息采用的轮询分发，但是在某种场景下这种策略并不是很好，比方说有两个消费者在处理任务，其中有个消费者1处理任务的速度非常快，而另外一个消费者2处理速度却很慢，这个时候我们还是采用轮询分发的化就会到这处理速度快的这个消费者很大一部分时间处于空闲状态，而处理慢的那个消费者一直在干活，这种分配方式在这种情况下其实就不太好，但是RabbitMQ并不知道这种情况它依然很公平的进行分发。\r\n\r\n为了避免这种情况，我们可以设置参数`channel.basicQos(1);`\r\n\r\n意思就是如果这个任务我还没有处理完或者我还没有应答你，你先别分配给我，找目刖只能理一个任务，然后RabbitMQ就会把该任务分配给没有那么忙的那个空闲消费者，当然如果所有的消费者都没有完成手上任务，队列还在不停的添加新任务，队列有可能就会遇到队列被撑满的情况，这个时候就只能添加新的worker或者改变其他存储任务的策略。\r\n\r\n## 预取值\r\n\r\n本身消息的发送就是异步发送的，所以在任何时候，channel上肯定不止只有一个消息另外来自消费者的手动确认本质上也是异步的。因此这里就存在一个未确认的消息缓冲区，因此希望开友人员能限制此缓冲区的大小，以避免缓冲区里面无限制的未确认消息问题。这个时候就可以通过使用`basic.gos`，方法设置“预取计数”值来完成的。该值定义通道上允许的未确认消息的最大数量。一旦数量达到配置的数量，RabbitMQ将停止在通道上传递更多消息，除非至少有一个未处理的消息被确认，例如，假设在通道上有未确认的消息5，6，7，8，并且通道的预取计数设置为4，此时RabbitMQ将不会在该通道上再传递任何消息，除非至少有一个未应答的消息被ack。比方说tag=6这个消息刚刚被确认ACK，RabbitMQ将会感知这个情况到并再发送一条消息。消息应答和QoS,预取值对用户吞吐量有重大影响。通常，增加预取将提高向消费者传递消息的速度。虽然自动应答传输消息速率是最佳的，但是，在这种情况下已传递但尚未处理的消息的数量也会增加，从而增加了消费者的RAM消耗(随机存取存储器)应该小心使用具有无限预处理的自动确认模式或手动确认模式，消费者消费了大量的消息如果没有确认的话，会导致消费者连接节点的内存消耗变大，所以找到合适的预取值是一个反复试验的过程，不同的负载该值取值也不同100到300范围内的值通常可提供最佳的吞吐量，并且不会给消费者带来太大的风险。预取值为1是最保守的。当然这将使吞吐量变得很低，特别是消费者连接延迟很严重的情况下，特别是在消费者连接等待时间较长的环境中，对于大多数应用来说，稍微高一点的值将是最佳的。\r\n\r\n# 发布确认\r\n\r\n## 发布确认原理\r\n\r\n生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会在将消息写入磁盘之后发出，broker回传给生产者的确认消息中delivery-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。\r\n\r\nconfirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条`nack`消息，生产者应用程序同样可以在回调方法中处理该`nack`消息。\r\n\r\n## 发布确认的策略\r\n\r\n### 开启发布确认的方法\r\n\r\n发布确认默认是没有开启的，如果要开启需要调用方法`confirmSelect`，每当你想要使用发布确认，都需要在channel上调用该方法。\r\n\r\n```java\r\nChannel channel = connection.createChannel();\r\nchannel.confirmSelect();\r\n```\r\n\r\n### 单个确认发布\r\n\r\n这是一种简单的确认方式，它是一种同步确认发布的方式，也就是发布一个消息之后只有它被确认发布，后续的消息才能继续发布，`waitForConfirmsOrDie(long)`这个方法只有在消息被确认的时候才返回，如果在指定时间范围内这个消息没有被确认那么它将抛出异常。\r\n\r\n这种确认方式有一个最大的缺点就是：发布速度特别慢，因为如果没有确认发布的消息就会阻塞所有后续消息的发布，这种方式最多提供每秒不超过数百条发布消息的吞吐量，当然对于某些应用程序来说这可能已经足够了。\r\n\r\n### 批量确认发布\r\n\r\n上面那种方式非常慢，与单个等待确认消息相比，先发布一批消息然后一起确认可以极大地提高吞吐量，当然这种方式的缺点就是：当发生故障导致发布出现问题时，不知道是哪个消息出现问题了，我们必须将整个批处理保存在内存中，以记录重要的信息而后重新发布消息。当然这种方案仍然是同步的，也一样阻塞消息的发布。\r\n\r\n### 异步确认发布\r\n\r\n异步确认虽然编程逻辑比上两个要复杂，但是性价比高，无论是可靠性还是效率都没的说，他是利用回调函数来达到消息可靠性传递的，这个中间件也是通过函数回调来保证是否投递成功。\r\n\r\n### 如何处理异步未确认消息\r\n\r\n最好的解决方案就是把未确认的消息放到一个基于内存的能被发布线程访问的队列，比如说用`ConcurrentLinkedQueue`这个队列在`confirm callbacks`与发布线程之间进行消息的传递。\r\n\r\n### 以上三种发布确认速度对比\r\n\r\n单独发布消息：同步等待确认，简单，但吞吐量非常有限。\r\n\r\n批量发布消息：批量同步等待确认，简单，合理的吞吐量，一旦出现问题很难推断出是哪条消息出现了问题。\r\n\r\n异步处理：最佳性能和资源使用，在出现错误的情况下可以很好的控制，但是实现起来稍微难一些。\r\n\r\n# 交换机\r\n\r\n在上一节中，我们创建了一个工作队列。我们假设的是工作队列背后，每个任务都恰好交付给一个消费者(工作进程)。在这一部分中，我们将做一些完全不同的事情。我们将消息传达给多个消费者。这种模式称为“发布/订阅\"。\r\n\r\n为了说明这种模式，我们将构建一个简单的日志系统。它将由两个程序组成：第一个程序将发出日志消息，第二个程序是消费者。其中我们会启动两个消费者，其中一个消费者接收到消息后把日志存储在磁盘，另外一个消费者接收到消息后把消息打印在屏幕上，事实上第一个程序发出的日志消息将广播给所有消费者。\r\n\r\n## Exchange\r\n\r\n### 概念\r\n\r\nRabbitMQ消息传递模型的核心思想是：生产者生产的消息从不会直接发送到队列。实际上，通常生产者甚至都不知道这些消息传递到了哪些队列中。\r\n\r\n相反，生产者只能将消息发送到交换机（exchange），交换机工作的内容非常简单，一方面它接收来自生产者的消息，另一方面将他们推入队列。交换机必须确切知道如何处理收到的消息。是应该把这些消息放到特定队列还是说把他们放到许多队列中还是应该丢弃他们。这由交换机的类型来决定。\r\n\r\n### 类型\r\n\r\n直接（direct），主题（topic），标题（headers），扇出（fanout）\r\n\r\n### 无名exchange\r\n\r\n在本教程的前面部分我们对exchange一无所知，但仍然能够将消息发送到队列。之前能实现的原因是因为我们使用的是默认交换，我们通过空字符串（\"\"）进行标识。\r\n\r\n```java\r\nchannel.basicPublish(\"\", \"hello\", null, message.getBytes());\r\n```\r\n\r\n第一个参数是交换机的名称。空字符串标识默认或无名称交换机：消息能从路由发送到队列中其实是由`routingKey(bindingkey)`绑定key指定的，如果它存在的话。\r\n\r\n## 临时队列\r\n\r\n每当我们连接到Rabbit时，我们都需要一个全新的空队列，为此我们可以创建一个具有随机名称的队列，或者能让服务器为我们选择一个随机队列名称那就更好了。其次一旦我们断开了消费者的连接，队列将被自动删除。\r\n\r\n创建临时队列的方式如下：\r\n\r\n```java\r\nString queueName = channel.queueDeclare().getQueue();\r\n```\r\n\r\n## 绑定\r\n\r\n什么是绑定（`bingding`）呢，`bingding`其实就是exchange和queue之间的桥梁，它告诉我们exchange和哪个队列进行了绑定关系。\r\n\r\n## Fanout\r\n\r\n它是将接收到的所有消息广播到它知道的所有队列中。系统中默认有些exchange类型。\r\n\r\n## Direct exchange\r\n\r\n在上一节中，我们构建了一个简单的日志记录系统。我们能够向许多接收者广播日志消息。在本节我们将向其中添加一些特别的功能，比方说我们只让某个消费者订阅发布的部分消息。例如我们只把严重错误消息定向存储到日志文件(以节省磁盘空间)，同时仍然能够在控制台上打印所有日志消息。\r\n\r\n我们再次来回顾一下什么是 bindings，绑定是交换机和队列之间的桥梁关系。也可以这么理解：队列只对它绑定的交换机的消息感兴趣。绑定用参数：`routingKey`来表示。也可称该参数为`binding key`，创建绑定我们用代码：`channel.queueBind(queueName, EXCHANGE_NAME, \"routingKey\");`绑定之后的意义由其交换类型决定。\r\n\r\n上一节中的我们的日志系统将所有消息广播给所有消费者，对此我们想做一些改变，例如我们希望将日志消息写入磁盘的程序仅接收严重错误(`erros`)，而不存储哪些警告(warning)或信息(info)日志消息避免浪费磁盘空间。Fanout这种交换类型并不能给我们带来很大的灵活性-它只能进行无意识的广播，在这里我们将使用direct这种类型来进行替换，这种类型的工作方式是，消息只去到它绑定的`routingKey`队列中去。\r\n\r\n![图片说明](https://uploadfiles.nowcoder.com/images/20221013/428825176_1665594699086/6AFF7B77F992D55D774DA8C82FE088ED \"图片标题\") \r\n\r\n在上面这张图中，我们可以看到X绑定了两个队列,绑定类型是direct。队列Q1绑定键为orange队列Q2绑定键有两个：一个绑定键为black，另一个绑定键为green。\r\n\r\n在这种绑定情况下，生产者发布消息到exchange上，绑定键为orange的消息会被发布到队列Q1。绑定键为`blackgreen`的消息会被发布到队列Q2，其他消息类型的消息将被丢弃。\r\n\r\n## 多重绑定\r\n\r\n![图片说明](https://uploadfiles.nowcoder.com/images/20221013/428825176_1665594721583/43D7CB07FA99B10FCFFCA5755EE22082 \"图片标题\") \r\n\r\n当然如果exchange的绑定类型是direct，但是它绑定的多个队列的key如果都相同，在这种情况下虽然绑定类型是direct但是它表现的就和fanout有点类似了，就跟广播差不多，如上图所示。\r\n\r\n## Topics\r\n\r\n### 之前类型的问题\r\n\r\n在上一个小节中，我们改进了日志记录系统。我们没有使用只能进行随意广播的fanout交换机，而是使用了direct交换机，从而有能实现有选择性地接收日志。\r\n\r\n尽管使用direct交换机改进了我们的系统，但是它仍然存在局限性。比方说我们想接收的日志类型有info.base和info.advantage，某个队列只想info.base的消息，那这个时候direct就办不到了。这个时候就只能使用topic类型。\r\n\r\n### Topic的要求\r\n\r\n发送到类型是topic交换机的消息的`routing_key`不能随便写，必须满足一定的要求，它必须是一个单词列表，以点号分隔开。这些单词可以是任意单词，比如说：\"`stock.usd.nyse`\"，\"`nyse.vmw`\"，\"`quick.orange.rabbit`\"这种类型的。当然这个单词列表最多不能超过255个字节。\r\n\r\n在这个规则列表中，其中有两个替换符是需要大家注意的\r\n\r\n*（星号）可以代替一个单词\r\n\r\n#（井号）可以代替零个或多个单词\r\n\r\n### Topic匹配案例\r\n\r\n中间带orange带3个单词的字符串（`*.orange.*`）\r\n\r\n最后一个单词是rabbit的3个单词（`*.*.rabbit`）\r\n\r\n第一个单词是lazy的多个单词（`lazy.#`）\r\n\r\n# 死信队列\r\n\r\n## 概念\r\n\r\n先从概念解释上搞清楚这个定义，死信，顾名思义就是无法被消费的消息，字面意思可以这样理解，一般来说，producer将消息投递到broker或者直接到queue里了，consumer 从 queue取出消息进行消费，但某些时候由于特定的原因导致queue中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。\r\n\r\n应用场景：为了保证订单业务的消息数据不丢失，需要使用到RabbitMQ的死信队列机制，当消息消费发生异常时，将消息投入死信队列中。还有比如说：用户在商城下单成功并点击去支付后在指定时间未支付时自动失效。\r\n\r\n## 来源\r\n\r\n消息TTL过期\r\n\r\n队列达到最大长度（队列满了，无法再添加数据到mq中）\r\n\r\n消息被拒绝（`basic.reject`或`basic.nack`）并且`requeue=false`\r\n\r\n# 延迟队列\r\n\r\n## 概念\r\n\r\n延时队列，队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望延时队列，队列内部是有序的，最重要的特性就体现在它的延时属性上，延时队列中的元素是希望。\r\n\r\n## 延迟队列使用场景\r\n\r\n1. 订单在十分钟之内未支付则自动取消\r\n2. 新创建的店铺，如果在十天内都没有上传过商品，则自动发送消息提醒\r\n3. 用户注册成功后，如果三天内没有登录则进行短信提醒\r\n4. 用户发起退款，如果三天内没有得到处理则通知相关运营人员\r\n5. 预定会议后，需要在预定的时间点前十分钟通知各个与会人员参加会议\r\n\r\n这些场景都有一个特点，需要在某个事件发生之后或者之前的指定时间点完成某一项任务，如：发生订单生成事件，在十分钟之后检查该订单支付状态，然后将未支付的订单进行关闭；看起来似乎使用定时任务，一直轮询数据，每秒查一次，取出需要被处理的数据，然后处理不就完事了吗？如果数据量比较少，确实可以这样做，比如：对于\"如果账单一周内未支付则进行自动结算\"这样的需求，如果对于时间不是严格限制，而是宽松意义上的一周，那么每天晚上跑个定时任务检查一下所有未支付的账单，确实也是一个可行的方案。但对于数据量比较大，并且时效性较强的场景，如：\"订单十分钟内未支付则关闭\"，短期内未支付的订单数据可能会有很多，活动期间甚至会达到百万甚至千万级别，对这么庞大的数据量仍旧使用轮询的方式显然是不可取的，很可能在一秒内无法完成所有订单的检查，同时会给数据库带来很大压力，无法满足业务要求而且性能低下。\r\n\r\n# 整合SpringBoot\r\n\r\napplication.properties\r\n\r\n```properties\r\nspring.rabbitmq.host=182.92.234.71\r\nspring.rabbitmq.port=5672\r\nspring.rabbitmq.username=admin\r\nspring.rabbitmq.password=123\r\n```\r\n\r\n# 队列TTL\r\n\r\n创建两个队列QA和QB，两者队列TTL分别设置为10S和40S，然后在创建一个交换机X和死信交换机Y，它们的类型都是direct，创建一个死信队列QD，它们的绑定关系如下：\r\n\r\n![图片说明](https://uploadfiles.nowcoder.com/images/20221013/428825176_1665594761447/5BE50809206E16E940C9835BB6540B40 \"图片标题\") \r\n\r\n延时队列优化：在这里新增了一个队列QC，绑定关系如下，该队列不设置TTL时间。\r\n\r\n![图片说明](https://uploadfiles.nowcoder.com/images/20221013/428825176_1665594794406/3B9C83C9509F5052FE1446778DDB44EA \"图片标题\") \r\n\r\n看起来似乎没什么问题，但是在最开始的时候，就介绍过如果使用在消息属性上设置TTL的方式，消息可能并不会按时“死亡“，因为RabbitMQ只会检查第一个消息是否过期，如果过期则丢到死信队列,如果第一个消息的延时时长很长，而第二个消息的延时时长很短，第二个消息并不会优先得到执行。\r\n\r\n# RabbitMQ插件实现延迟队列\r\n\r\n上文中提到的问题，确实是一个问题，如果不能实现在消息粒度上的TTL，并使其在设置的TTL时间及时死亡，就无法设计成一个通用的延时队列。那如何解决呢，接下来我们就去解决该问题。\r\n\r\n## 安装延时队列插件\r\n\r\n在官网上\r\n\r\nhttps://www.rabbitmq.com/community-plugins.html\r\n\r\n下载`rabbitmq_delayed_message_exchange`插件，然后解压放置到RabbitMQ插件目录。进入RabbitMQ的安装目录下的plugins目录，执行下面命令让该插件生效，然后重启RabbitMQ。\r\n\r\n`/usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins`\r\n\r\n```shell\r\nrabbitmq-plugins enable rabbitmq_delayed_message_exchange\r\n```\r\n\r\n## 配置文件类代码\r\n\r\n在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制，消息传递后并不会立刻投递到目标队列中，而是存储在`mnesia`（一个分布式数据系统）表中，当达到投递时间时，才投递到目标队列中。\r\n\r\n## 总结\r\n\r\n延时队列在需要延时处理的场景下非常有用，使用RabbitMQ来实现延时队列可以很好的利用RabbitMQ的特性，如：消息可靠发送、消息可靠投递、死信队列来保障消息至少被消费一次以及未被正确处理的消息不会被丢弃。另外，通过RabbitMQ集群的特性，可以很好的解决单点故障问题，不会因为单个节点挂掉导致延时队列不可用或者消息丢失。\r\n\r\n当然，延时队列还有很多其它选择，比如利用Java的`DelayQueue`，利用Redis,的`zset`，利用Quartz或者利用Kafka的时间轮，这些方式各有特点,看需要适用的场景。\r\n\r\n",
      "data": {
        "title": "RabbitMQ",
        "date": "2022-10-19 12:21:50",
        "tags": [
          "RabbitMQ"
        ],
        "published": true,
        "hideInList": false,
        "feature": null,
        "isTop": false
      },
      "isEmpty": false,
      "excerpt": "",
      "abstract": "",
      "fileName": "rabbitmq"
    }
  ],
  "tags": [
    {
      "name": "Spring",
      "slug": "_5zkyH9T6",
      "used": true
    },
    {
      "name": "Java",
      "slug": "A6_mKHEp0",
      "used": true
    },
    {
      "name": "MySQL",
      "slug": "JLxxdPbkv",
      "used": true
    },
    {
      "name": "Redis",
      "slug": "BC_33sa6I",
      "used": true
    },
    {
      "name": "RabbitMQ",
      "slug": "-ylxhXN_w",
      "used": true
    },
    {
      "name": "Gridea",
      "slug": "lgvBcrGom",
      "used": false
    }
  ],
  "menus": [
    {
      "link": "/",
      "name": "首页",
      "openType": "Internal"
    },
    {
      "link": "/archives",
      "name": "归档",
      "openType": "Internal"
    },
    {
      "link": "/tags",
      "name": "标签",
      "openType": "Internal"
    }
  ]
}